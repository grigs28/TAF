{% extends "base.html" %}

{% block title %}{{ app_name }} - 备份管理{% endblock %}

{% block extra_css %}
<style>
.task-card {
    transition: all 0.3s ease;
    border-left: 4px solid transparent;
}
.task-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}
.task-running { border-left-color: #007bff; }
.task-completed { border-left-color: #28a745; }
.task-failed { border-left-color: #dc3545; }
.task-pending { border-left-color: #ffc107; }

.progress-circle {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 0.8rem;
}
</style>
{% endblock %}

{% block content %}
<div class="console-panel">
    <div class="d-flex justify-content-between align-items-center mb-4">
        <h5 class="mb-0">
            <i class="bi bi-cloud-upload me-2"></i>备份管理
        </h5>
        <div class="btn-group">
            <button class="btn btn-success" onclick="window.location.href='/system#scheduler'; setTimeout(() => { const btn = document.getElementById('addScheduledTaskBtn'); if (btn) btn.click(); }, 500);">
                <i class="bi bi-calendar-check me-2"></i>创建计划备份
            </button>
        </div>
    </div>
    
    <!-- 提示信息 -->
    <div class="alert alert-info alert-dismissible fade show" role="alert">
        <i class="bi bi-info-circle me-2"></i>
        <strong>提示：</strong>推荐使用 <a href="/system#scheduler" class="alert-link">计划任务模块</a> 创建定期备份任务，支持多种调度方式（每日、每周、每月等）。
        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    </div>

    <!-- 统计信息 -->
    <div class="row mb-4">
        <div class="col-md-3">
            <div class="service-card">
                <div class="card-body">
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <h6 class="mb-2">总任务数</h6>
                            <h3 class="mb-0" id="totalTasks">-</h3>
                        </div>
                        <div class="ai-icon">
                            <i class="bi bi-stack"></i>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="service-card">
                <div class="card-body">
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <h6 class="mb-2">成功</h6>
                            <h3 class="mb-0" id="completedTasks">-</h3>
                        </div>
                        <div class="ai-icon">
                            <i class="bi bi-check-circle"></i>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="service-card">
                <div class="card-body">
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <h6 class="mb-2">运行中</h6>
                            <h3 class="mb-0" id="runningTasks">-</h3>
                        </div>
                        <div class="ai-icon">
                            <i class="bi bi-hourglass-split"></i>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="service-card">
                <div class="card-body">
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <h6 class="mb-2">失败</h6>
                            <h3 class="mb-0" id="failedTasks">-</h3>
                        </div>
                        <div class="ai-icon">
                            <i class="bi bi-x-circle"></i>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 筛选条件和运行中的任务 -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="service-card">
                <div class="card-body">
                    <!-- 筛选条件 -->
                    <h6 class="mb-3">
                        <i class="bi bi-funnel me-2"></i>筛选条件
                    </h6>
                    <div class="row mb-4">
                        <div class="col-md-3">
                            <select class="form-select bg-dark text-light" id="statusFilter">
                                <option value="">所有状态</option>
                                <option value="running">运行中</option>
                                <option value="completed">已完成</option>
                                <option value="failed">失败</option>
                                <option value="pending">等待中</option>
                                <option value="not_run">未运行</option>
                            </select>
                        </div>
                        <div class="col-md-3">
                            <select class="form-select bg-dark text-light" id="typeFilter">
                                <option value="">所有类型</option>
                                <option value="full">完整备份</option>
                                <option value="incremental">增量备份</option>
                                <option value="differential">差异备份</option>
                                <option value="monthly_full">月度备份</option>
                            </select>
                        </div>
                        <div class="col-md-4">
                            <input type="text" class="form-control bg-dark text-light" id="searchInput" placeholder="搜索备份任务...">
                        </div>
                        <div class="col-md-2">
                            <button class="btn btn-outline-secondary w-100" id="searchBtn">
                                <i class="bi bi-search me-1"></i>搜索
                            </button>
                        </div>
                    </div>

                    <!-- 运行中的任务和最近失败的任务 -->
                    <h6 class="mb-3">
                        <i class="bi bi-hourglass-split me-2"></i>运行中的任务和最近失败的任务
                    </h6>
                    <div class="row" id="runningTasksList">
                        <div class="col-12">
                            <p class="text-muted">加载中...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 所有任务列表 -->
    <div class="row">
        <div class="col-12">
            <div class="service-card">
                <div class="card-body">
                    <h6 class="mb-3">
                        <i class="bi bi-list-ul me-2"></i>所有任务
                    </h6>
                    <div class="table-responsive">
                        <table class="table table-hover">
                            <thead>
                                <tr>
                                    <th>任务名称</th>
                                    <th>类型</th>
                                    <th>源路径</th>
                                    <th>状态</th>
                                    <th>开始时间</th>
                                    <th>完成时间</th>
                                    <th>数据大小</th>
                                    <th>操作</th>
                                </tr>
                            </thead>
                            <tbody id="allTasksTable">
                                <tr>
                                    <td colspan="8" class="text-center text-muted">加载中...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- 引入计划任务模态框 -->
{% include 'system/_modal_scheduler_task.html' %}
{% include 'system/_modal_directory_browser.html' %}

<script>
// 加载备份统计数据
async function loadBackupStatistics() {
    try {
        const response = await fetch('/api/backup/statistics');
        const stats = await response.json();
        
        if (stats) {
            document.getElementById('totalTasks').textContent = stats.total_tasks || 0;
            document.getElementById('completedTasks').textContent = stats.completed_tasks || 0;
            document.getElementById('runningTasks').textContent = stats.running_tasks || 0;
            document.getElementById('failedTasks').textContent = stats.failed_tasks || 0;
        }
    } catch (error) {
        console.error('加载备份统计失败:', error);
    }
}

// 格式化字节大小
function formatBytes(bytes) {
    if (!bytes || bytes === 0) return '-';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return (bytes / Math.pow(k, i)).toFixed(2) + ' ' + sizes[i];
}

// 格式化字节为GB单位
function formatBytesToGB(bytes) {
    if (!bytes || bytes === 0) return '0 G';
    const gb = bytes / (1024 * 1024 * 1024);
    return gb.toFixed(2) + ' G';
}

// 格式化日期时间
function formatDateTime(dateStr) {
    if (!dateStr) return '-';
    const date = new Date(dateStr);
    return date.toLocaleString('zh-CN', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
    });
}

// 格式化时间差（已用时间）
function formatElapsedTime(startedAt, completedAt) {
    if (!startedAt) return '-';
    
    const startTime = new Date(startedAt);
    const endTime = completedAt ? new Date(completedAt) : new Date();
    const diffMs = endTime - startTime;
    
    if (diffMs < 0) return '-';
    
    const seconds = Math.floor(diffMs / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    
    if (days > 0) {
        return `${days}天 ${hours % 24}小时 ${minutes % 60}分钟`;
    } else if (hours > 0) {
        return `${hours}小时 ${minutes % 60}分钟`;
    } else if (minutes > 0) {
        return `${minutes}分钟 ${seconds % 60}秒`;
    } else {
        return `${seconds}秒`;
    }
}

// 格式化任务类型
function formatTaskType(taskType) {
    const typeMap = {
        'full': { text: '完整备份', class: 'bg-info' },
        'incremental': { text: '增量备份', class: 'bg-secondary' },
        'differential': { text: '差异备份', class: 'bg-warning' },
        'monthly_full': { text: '月度备份', class: 'bg-primary' }
    };
    const type = typeMap[taskType] || { text: taskType, class: 'bg-secondary' };
    return `<span class="badge ${type.class}">${type.text}</span>`;
}

// 格式化状态
function formatStatus(status, description) {
    const statusMap = {
        'completed': { text: '成功', class: 'bg-success' },
        'failed': { text: '失败', class: 'bg-danger' },
        'running': { text: '运行中', class: 'bg-primary' },
        'pending': { text: '等待中', class: 'bg-warning' },
        'cancelled': { text: '已取消', class: 'bg-secondary' },
        'paused': { text: '已暂停', class: 'bg-secondary' }
    };
    let s = statusMap[status] || { text: status, class: 'bg-secondary' };
    
    // 如果description中包含"格式化中"，显示格式化状态
    if (description && description.includes('[格式化中]')) {
        s = { text: '格式化中', class: 'bg-info' };
    }
    
    return `<span class="badge ${s.class}">${s.text}</span>`;
}

// 获取操作状态显示HTML
function getOperationStatus(description) {
    if (!description) return '';
    
    // 检查格式化状态（格式：[格式化中]）
    if (description.includes('[格式化中]')) {
        return `<div class="mb-2"><small class="text-info"><i class="bi bi-info-circle me-1"></i>正在格式化磁带...</small></div>`;
    }
    
    // 提取操作状态（格式：[操作状态...]）
    const operationMatch = description.match(/\[([^\]]+\.\.\.)\]/);
    if (!operationMatch) return '';
    
    const operationText = operationMatch[1];
    let icon = 'bi-hourglass-split';
    let colorClass = 'text-info';
    
    // 根据操作类型选择图标和颜色
    if (operationText.includes('扫描')) {
        icon = 'bi-search';
        colorClass = 'text-primary';
    } else if (operationText.includes('压缩')) {
        icon = 'bi-archive';
        colorClass = 'text-warning';
    } else if (operationText.includes('写入')) {
        icon = 'bi-hdd';
        colorClass = 'text-success';
    } else if (operationText.includes('完成')) {
        icon = 'bi-check-circle';
        colorClass = 'text-success';
    } else if (operationText.includes('准备')) {
        icon = 'bi-gear';
        colorClass = 'text-info';
    }
    
    return `<div class="mb-2"><small class="${colorClass}"><i class="bi ${icon} me-1"></i>${operationText}</small></div>`;
}

// 运行中任务的轮询间隔
let runningTasksPollInterval = null;
let runningTaskCards = new Map(); // 存储运行中任务卡片的DOM元素和任务ID映射

// 加载运行中的任务和最近失败的任务（带实时验证和更新）
async function loadRunningTasks() {
    try {
        // 同时获取运行中和最近失败的任务（最近10分钟内失败的）
        const [runningResponse, failedResponse] = await Promise.all([
            fetch('/api/backup/tasks?status=running&limit=10'),
            fetch('/api/backup/tasks?status=failed&limit=5')
        ]);
        
        const runningTasks = await runningResponse.json();
        const failedTasks = await failedResponse.json();
        
        const container = document.getElementById('runningTasksList');
        if (!container) return;
        
        // 获取当前显示的任务ID
        const currentTaskIds = new Set();
        
        // 验证每个任务是否真的还在运行
        const validTasks = [];
        
        // 处理运行中的任务
        for (const task of (runningTasks || [])) {
            try {
                // 验证任务状态
                const statusResponse = await fetch(`/api/backup/tasks/${task.task_id || task.id}/status`);
                if (statusResponse.ok) {
                    const status = await statusResponse.json();
                    // 只显示真正运行中的任务
                    if (status && status.status === 'running') {
                        validTasks.push({
                            ...task,
                            status: status.status,
                            progress_percent: status.progress_percent || task.progress_percent || 0,
                            processed_files: status.processed_files || task.processed_files || 0,
                            total_files: status.total_files || task.total_files || 0,
                            total_bytes: status.total_bytes || task.total_bytes || 0,
                            processed_bytes: status.processed_bytes || task.processed_bytes || 0,
                            compressed_bytes: status.compressed_bytes || task.compressed_bytes || 0,
                            compression_ratio: status.compression_ratio || task.compression_ratio || 0,
                            estimated_archive_count: status.estimated_archive_count || task.estimated_archive_count || null,
                            description: status.description || task.description || '',
                            source_paths: status.source_paths || task.source_paths || [],
                            tape_device: status.tape_device || task.tape_device || null,
                            tape_id: status.tape_id || task.tape_id || null,
                            started_at: status.started_at || task.started_at || null,
                            completed_at: status.completed_at || task.completed_at || null
                        });
                        currentTaskIds.add(task.task_id || task.id);
                    }
                }
            } catch (statusError) {
                console.warn(`验证任务 ${task.task_id || task.id} 状态失败:`, statusError);
                // 如果无法验证，仍然显示（可能只是网络问题）
                if (task.status === 'running') {
                    validTasks.push(task);
                    currentTaskIds.add(task.task_id || task.id);
                }
            }
        }
        
        // 处理最近失败的任务（只显示最近10分钟内失败的）
        const now = new Date();
        const tenMinutesAgo = new Date(now.getTime() - 10 * 60 * 1000);
        
        for (const task of (failedTasks || [])) {
            // 检查任务是否在最近10分钟内失败
            const completedAt = task.completed_at ? new Date(task.completed_at) : null;
            if (completedAt && completedAt >= tenMinutesAgo) {
                validTasks.push({
                    ...task,
                    status: 'failed',
                    progress_percent: task.progress_percent || 0,
                    processed_files: task.processed_files || 0,
                    total_files: task.total_files || 0,
                    description: task.description || ''
                });
                currentTaskIds.add(task.task_id || task.id);
            }
        }
        
        // 移除已不在运行中的任务卡片
        const cardsToRemove = [];
        runningTaskCards.forEach((cardElement, taskId) => {
            if (!currentTaskIds.has(taskId)) {
                cardsToRemove.push(cardElement);
                runningTaskCards.delete(taskId);
            }
        });
        cardsToRemove.forEach(card => card.remove());
        
        // 更新或添加任务卡片
        validTasks.forEach(task => {
            const taskId = task.task_id || task.id;
            // 优先使用从status API获取的source_paths，否则使用task中的
            // 确保source_paths不为空，如果为空则显示"N/A"
            let sourcePaths = 'N/A';
            if (task.source_paths) {
                if (Array.isArray(task.source_paths)) {
                    sourcePaths = task.source_paths.length > 0 ? task.source_paths.join(', ') : 'N/A';
                } else if (typeof task.source_paths === 'string' && task.source_paths.trim()) {
                    sourcePaths = task.source_paths;
                }
            }
            const progress = Math.max(0, Math.min(100, task.progress_percent || 0));
            const startedTime = task.started_at ? formatDateTime(task.started_at) : '-';
            const elapsedTime = formatElapsedTime(task.started_at, task.completed_at);
            // 优先使用tape_device，其次tape_id，最后默认值
            const tapeInfo = task.tape_device || task.tape_id || '自动选择';
            
            // 计算压缩率：优先使用API返回的compression_ratio，否则根据compressed_bytes和processed_bytes计算
            let compressionRatio = '0.00';
            if (task.compression_ratio && task.compression_ratio > 0) {
                compressionRatio = task.compression_ratio.toString();
            } else if (task.compressed_bytes && task.processed_bytes && task.processed_bytes > 0) {
                compressionRatio = (task.compressed_bytes / task.processed_bytes).toFixed(2);
            }
            
            // 文件进度：已处理文件/总文件数
            const processedFiles = task.processed_files || 0;  // 已处理文件数
            const totalScannedFiles = task.total_files || 0;  // 总文件数（由后台扫描任务更新）
            
            // 数据量进度
            const processedBytes = task.processed_bytes || 0;  // 已处理字节数
            const totalBytesActual = task.total_bytes || null;  // 总字节数（由后台扫描任务更新）
            
            // 预估总字节数（如果后端未提供）
            let estimatedTotalBytes = null;
            if (!totalBytesActual || totalBytesActual === 0) {
                // 策略1：如果已处理文件数和字节数都有，计算平均文件大小，然后预估总字节数
                if (processedFiles > 0 && processedBytes > 0 && totalScannedFiles > 0) {
                    const avgFileSize = processedBytes / processedFiles;
                    estimatedTotalBytes = Math.round(avgFileSize * totalScannedFiles);
                }
                // 策略2：如果只有已处理字节数，根据当前进度预估（保守估算）
                else if (processedBytes > 0 && progress > 0 && progress < 100) {
                    // 假设当前进度是准确的，预估总字节数
                    estimatedTotalBytes = Math.round(processedBytes / (progress / 100));
                }
                // 策略3：如果已处理字节数 > 0 但其他信息不足，使用保守倍数估算
                else if (processedBytes > 0) {
                    // 保守估算：假设已处理的数据量占总量的10-50%
                    estimatedTotalBytes = Math.round(processedBytes * 3); // 假设已处理33%，保守估算
                }
            }
            
            // 使用实际总字节数或预估总字节数
            const totalBytes = totalBytesActual || estimatedTotalBytes || 0;
            
            // 改进的进度计算：基于多因素加权
            let calculatedProgress = progress;
            
            // 方案1：如果API返回了准确的进度，优先使用
            if (progress > 0 && progress <= 100 && progress < 99.9) {
                // 如果API进度不是接近完成，优先使用
                calculatedProgress = progress;
            } 
            // 方案2：基于数据量的进度（最准确）
            else if (totalBytes > 0 && processedBytes > 0) {
                const bytesProgressRatio = processedBytes / totalBytes;
                // 数据量进度占主要权重（80%）
                calculatedProgress = bytesProgressRatio * 100;
                
                // 如果有文件数信息，结合文件数进度进行微调（20%权重）
                if (totalScannedFiles > 0 && processedFiles > 0) {
                    const fileProgressRatio = processedFiles / totalScannedFiles;
                    // 加权平均：数据量80% + 文件数20%
                    calculatedProgress = (bytesProgressRatio * 0.8 + fileProgressRatio * 0.2) * 100;
                }
            }
            // 方案3：基于文件数的进度（适用于文件大小差异不大的情况）
            else if (totalScannedFiles > 0 && processedFiles > 0) {
                const fileProgressRatio = processedFiles / totalScannedFiles;
                // 文件数进度占70%权重（扫描阶段）
                calculatedProgress = fileProgressRatio * 70;
                
                // 如果已处理数据量 > 0，说明已进入压缩/写入阶段，进度应该 > 70%
                if (processedBytes > 0) {
                    const compressionRatio = task.compression_ratio || 0;
                    if (compressionRatio > 0) {
                        // 有压缩率信息，说明压缩阶段在进行
                        calculatedProgress = 70 + (compressionRatio * 0.3 * 100); // 压缩阶段占30%
                    } else {
                        // 没有压缩率，可能是扫描阶段，进度保持在文件数进度
                        calculatedProgress = Math.min(95, fileProgressRatio * 100);
                    }
                }
            } 
            // 方案4：如果只有已处理文件数，使用保守估算
            else if (processedFiles > 0) {
                // 保守估算：已处理文件数越多，进度越高，但不超过90%
                calculatedProgress = Math.min(90, Math.sqrt(processedFiles / 100) * 50);
            } 
            // 方案5：初始阶段
            else {
                calculatedProgress = 0.0;
            }
            
            // 确保进度在合理范围内
            calculatedProgress = Math.max(0, Math.min(100, calculatedProgress));
            
            // 使用计算出的进度，如果API返回的进度更准确，优先使用API的进度
            const finalProgress = Math.max(calculatedProgress, progress);
            
            // 检查是否已有该任务的卡片
            let taskCard = runningTaskCards.get(taskId);
            
            // 判断任务状态
            const isFormatting = task.description && task.description.includes('[格式化中]');
            const isFailed = task.status === 'failed';
            let statusBadge, statusText;
            if (isFailed) {
                statusBadge = '<span class="badge bg-danger">失败</span>';
                statusText = '失败';
            } else if (isFormatting) {
                statusBadge = '<span class="badge bg-info">格式化中</span>';
                statusText = '格式化中';
            } else {
                statusBadge = '<span class="badge bg-primary">运行中</span>';
                statusText = '运行中';
            }
            
            if (taskCard) {
                // 更新现有卡片
                const progressBar = taskCard.querySelector('.progress-bar');
                // 更精确地选择百分比文本：找到包含进度条的mb-2容器，然后找到其中的百分比文本
                const mb2Elements = taskCard.querySelectorAll('.mb-2');
                let progressText = null;
                for (const mb2 of mb2Elements) {
                    if (mb2.querySelector('.progress-bar')) {
                        progressText = mb2.querySelector('.d-flex.justify-content-between .text-muted:last-child');
                        break;
                    }
                }
                // 选择文件数文本：最后一个d-flex中的最后一个text-muted
                const filesInfo = taskCard.querySelector('.d-flex.justify-content-between:last-of-type .text-muted:last-child');
                // 更新状态徽章
                const statusBadgeEl = taskCard.querySelector('.badge');
                if (statusBadgeEl) {
                    statusBadgeEl.outerHTML = statusBadge;
                }
                
                // 更新源路径和目标信息
                const sourcePathEl = taskCard.querySelector('code');
                if (sourcePathEl && sourcePathEl.textContent) {
                    // 找到源路径的code元素（在"源路径:"标签后的code）
                    const allCodes = taskCard.querySelectorAll('code');
                    if (allCodes.length >= 2) {
                        // 第一个code是源路径
                        allCodes[0].textContent = sourcePaths;
                        allCodes[0].classList.add('text-white'); // 添加白色样式
                        // 第二个code是目标
                        allCodes[1].textContent = tapeInfo;
                        // 如果包含scsi路径，添加白色样式
                        if (tapeInfo.includes('\\\\.\\\\scsi') || tapeInfo.includes('\\\\.\\scsi')) {
                            allCodes[1].classList.add('text-white');
                        } else {
                            allCodes[1].classList.remove('text-white');
                        }
                    } else if (allCodes.length === 1) {
                        // 只有一个code，可能是源路径
                        allCodes[0].textContent = sourcePaths;
                        allCodes[0].classList.add('text-white'); // 添加白色样式
                    }
                } else {
                    // 如果找不到code元素，尝试通过文本内容查找
                    const mb2Elements = taskCard.querySelectorAll('.mb-2');
                    for (const mb2 of mb2Elements) {
                        const label = mb2.querySelector('small.text-muted');
                        if (label && label.textContent.includes('源路径')) {
                            const codeEl = mb2.querySelector('code');
                            if (codeEl) {
                                codeEl.textContent = sourcePaths;
                                codeEl.classList.add('text-white'); // 添加白色样式
                            }
                        } else if (label && label.textContent.includes('目标')) {
                            const codeEl = mb2.querySelector('code');
                            if (codeEl) {
                                codeEl.textContent = tapeInfo;
                                // 如果包含scsi路径，添加白色样式
                                if (tapeInfo.includes('\\\\.\\\\scsi') || tapeInfo.includes('\\\\.\\scsi')) {
                                    codeEl.classList.add('text-white');
                                } else {
                                    codeEl.classList.remove('text-white');
                                }
                            }
                        }
                    }
                }
                
                // 更新开始时间
                const startedTimeEl = Array.from(taskCard.querySelectorAll('.mb-2 .d-flex.justify-content-between')).find(el => 
                    el.textContent.includes('开始时间')
                );
                if (startedTimeEl) {
                    const startedTimeValue = startedTimeEl.querySelector('.text-muted:last-child');
                    if (startedTimeValue) {
                        startedTimeValue.textContent = startedTime;
                    }
                }
                
                // 更新操作状态显示（确保从最新的status获取description）
                const operationStatusEl = taskCard.querySelector('.operation-status');
                // 优先使用从status API获取的最新description
                const latestDescription = task.description || '';
                const newStatusHtml = getOperationStatus(latestDescription);
                
                if (operationStatusEl) {
                    if (newStatusHtml) {
                        // 更新操作状态元素
                        operationStatusEl.outerHTML = newStatusHtml.replace('class="mb-2"', 'class="mb-2 operation-status"');
                    } else {
                        // 如果没有操作状态，移除元素
                        operationStatusEl.remove();
                    }
                } else if (newStatusHtml) {
                    // 如果操作状态元素不存在，但description中有操作状态，添加它
                    const cardBody = taskCard.querySelector('.card-body');
                    // 找到格式化提示或错误提示之后的位置插入
                    const formattingEl = cardBody.querySelector('.text-info');
                    const errorEl = cardBody.querySelector('.text-danger');
                    
                    if (errorEl) {
                        errorEl.insertAdjacentHTML('afterend', newStatusHtml.replace('class="mb-2"', 'class="mb-2 operation-status"'));
                    } else if (formattingEl) {
                        formattingEl.parentElement.insertAdjacentHTML('afterend', newStatusHtml.replace('class="mb-2"', 'class="mb-2 operation-status"'));
                    } else {
                        // 如果没有格式化或错误提示，在标题后插入
                        const titleEl = cardBody.querySelector('.card-title');
                        if (titleEl) {
                            titleEl.parentElement.insertAdjacentHTML('afterend', newStatusHtml.replace('class="mb-2"', 'class="mb-2 operation-status"'));
                        } else {
                            const firstMb2 = cardBody.querySelector('.mb-2');
                            if (firstMb2) {
                                firstMb2.insertAdjacentHTML('beforebegin', newStatusHtml.replace('class="mb-2"', 'class="mb-2 operation-status"'));
                            }
                        }
                    }
                }
                
                // 改进的进度计算：基于多因素加权
                let calculatedProgress = progress;
                
                const processedFiles = task.processed_files || 0;
                const totalScannedFiles = task.total_files || 0;  // 总文件数（由后台扫描任务更新）
                const processedBytes = task.processed_bytes || 0;
                const totalBytesActual = task.total_bytes || null;  // 总字节数（由后台扫描任务更新）
                
                // 预估总字节数（如果后端未提供）
                let estimatedTotalBytes = null;
                if (!totalBytesActual || totalBytesActual === 0) {
                    if (processedFiles > 0 && processedBytes > 0 && totalScannedFiles > 0) {
                        const avgFileSize = processedBytes / processedFiles;
                        estimatedTotalBytes = Math.round(avgFileSize * totalScannedFiles);
                    } else if (processedBytes > 0 && progress > 0 && progress < 100) {
                        estimatedTotalBytes = Math.round(processedBytes / (progress / 100));
                    } else if (processedBytes > 0) {
                        estimatedTotalBytes = Math.round(processedBytes * 3);
                    }
                }
                
                const totalBytes = totalBytesActual || estimatedTotalBytes || 0;
                
                // 方案1：如果API返回了准确的进度，优先使用
                if (progress > 0 && progress <= 100 && progress < 99.9) {
                    calculatedProgress = progress;
                } 
                // 方案2：基于数据量的进度（最准确）
                else if (totalBytes > 0 && processedBytes > 0) {
                    const bytesProgressRatio = processedBytes / totalBytes;
                    calculatedProgress = bytesProgressRatio * 100;
                    
                    if (totalScannedFiles > 0 && processedFiles > 0) {
                        const fileProgressRatio = processedFiles / totalScannedFiles;
                        calculatedProgress = (bytesProgressRatio * 0.8 + fileProgressRatio * 0.2) * 100;
                    }
                }
                // 方案3：基于文件数的进度
                else if (totalScannedFiles > 0 && processedFiles > 0) {
                    const fileProgressRatio = processedFiles / totalScannedFiles;
                    calculatedProgress = fileProgressRatio * 70;
                    
                    if (processedBytes > 0) {
                        const compressionRatio = task.compression_ratio || 0;
                        if (compressionRatio > 0) {
                            calculatedProgress = 70 + (compressionRatio * 0.3 * 100);
                        } else {
                            calculatedProgress = Math.min(95, fileProgressRatio * 100);
                        }
                    }
                } 
                // 方案4：如果只有已处理文件数，使用保守估算
                else if (processedFiles > 0) {
                    calculatedProgress = Math.min(90, Math.sqrt(processedFiles / 100) * 50);
                } 
                // 方案5：初始阶段
                else {
                    calculatedProgress = 10.0;
                }
                
                calculatedProgress = Math.max(0, Math.min(100, calculatedProgress));
                const finalProgress = Math.max(calculatedProgress, progress);
                
                if (progressBar) {
                    progressBar.style.width = finalProgress + '%';
                    progressBar.setAttribute('aria-valuenow', finalProgress);
                }
                if (progressText) {
                    progressText.textContent = finalProgress.toFixed(1) + '%';
                }
                // 更新文件进度和已处理文件大小信息
                const fileProgressEl = taskCard.querySelector('.mb-2 .d-flex.justify-content-between');
                if (fileProgressEl) {
                    // 更新文件进度：已处理文件/批次相加的文件数
                    const fileProgressRow = Array.from(taskCard.querySelectorAll('.mb-2 .d-flex.justify-content-between')).find(el => 
                        el.textContent.includes('文件进度')
                    );
                    if (fileProgressRow) {
                        const fileProgressValue = fileProgressRow.querySelector('.text-muted:last-child');
                        if (fileProgressValue) {
                            const processedFiles = task.processed_files || 0;  // 已处理文件数
                            const totalScannedFiles = task.total_files || 0;  // 总文件数（由后台扫描任务更新）
                            fileProgressValue.textContent = `${processedFiles}/${totalScannedFiles || processedFiles}`;
                        }
                    }
                    
                    // 更新数据量：显示独立扫描的文件总大小（total_bytes），如果有压缩数据则显示压缩大小/总大小
                    const processedSizeRow = Array.from(taskCard.querySelectorAll('.mb-2 .d-flex.justify-content-between')).find(el => 
                        el.textContent.includes('数据量')
                    );
                    if (processedSizeRow) {
                        const processedSizeValue = processedSizeRow.querySelector('.text-muted:last-child');
                        if (processedSizeValue) {
                            const totalBytes = task.total_bytes || 0;  // 独立扫描的文件总大小
                            const compressedBytes = task.compressed_bytes || 0;  // 压缩后文件大小
                            
                            if (compressedBytes > 0 && totalBytes > 0) {
                                // 显示格式：压缩大小/总大小
                                processedSizeValue.textContent = `${formatBytes(compressedBytes)}/${formatBytes(totalBytes)}`;
                            } else if (totalBytes > 0) {
                                // 只显示总大小
                                processedSizeValue.textContent = formatBytes(totalBytes);
                            } else {
                                // 如果没有总大小，显示已处理字节数（向后兼容）
                                processedSizeValue.textContent = formatBytes(task.processed_bytes || 0);
                            }
                        }
                    }
                    
                    // 更新已用时间
                    const elapsedTimeRow = Array.from(taskCard.querySelectorAll('.mb-2 .d-flex.justify-content-between')).find(el => 
                        el.textContent.includes('已用时间')
                    );
                    if (elapsedTimeRow) {
                        const elapsedTimeValue = elapsedTimeRow.querySelector('.text-muted:last-child');
                        if (elapsedTimeValue) {
                            elapsedTimeValue.textContent = formatElapsedTime(task.started_at, task.completed_at);
                        }
                    }
                    
                    // 更新压缩率（如果存在）
                    if (task.compressed_bytes > 0 && task.processed_bytes > 0) {
                        const compressionRatioRow = Array.from(taskCard.querySelectorAll('.mb-2 .d-flex.justify-content-between')).find(el => 
                            el.textContent.includes('压缩率')
                        );
                        if (compressionRatioRow) {
                            const compressionRatioValue = compressionRatioRow.querySelector('.text-muted:last-child');
                            if (compressionRatioValue) {
                                // 计算压缩率：优先使用API返回的compression_ratio
                                let ratio = 0;
                                if (task.compression_ratio && task.compression_ratio > 0) {
                                    ratio = task.compression_ratio;
                                } else {
                                    ratio = task.compressed_bytes / task.processed_bytes;
                                }
                                compressionRatioValue.textContent = `${(ratio * 100).toFixed(1)}%`;
                            }
                        } else {
                            // 如果压缩率行不存在，添加它
                            const fileProgressRow = Array.from(taskCard.querySelectorAll('.mb-2 .d-flex.justify-content-between')).find(el => 
                                el.textContent.includes('已处理文件')
                            );
                            if (fileProgressRow) {
                                const mb2Container = fileProgressRow.parentElement;
                                if (mb2Container) {
                                    let ratio = 0;
                                    if (task.compression_ratio && task.compression_ratio > 0) {
                                        ratio = task.compression_ratio;
                                    } else {
                                        ratio = task.compressed_bytes / task.processed_bytes;
                                    }
                                    const compressionHtml = `
                                        <div class="d-flex justify-content-between">
                                            <small class="text-muted">压缩率:</small>
                                            <small class="text-muted">${(ratio * 100).toFixed(1)}%</small>
                                        </div>
                                    `;
                                    mb2Container.insertAdjacentHTML('beforeend', compressionHtml);
                                }
                            }
                        }
                    }
                } else if (fileProgressEl && fileProgressEl.textContent.includes('文件处理进度')) {
                    // 兼容旧格式：更新文件处理进度
                    const progressValue = fileProgressEl.querySelector('.text-muted:last-child');
                    if (progressValue) {
                        progressValue.textContent = `${task.processed_files || 0}/${task.total_files || 0}`;
                    }
                    
                    // 更新压缩率（如果存在）
                    if (task.compressed_bytes > 0 && task.processed_bytes > 0) {
                        const compressionRatioRow = Array.from(taskCard.querySelectorAll('.mb-2 .d-flex.justify-content-between')).find(el => 
                            el.textContent.includes('压缩率')
                        );
                        if (compressionRatioRow) {
                            const compressionRatioValue = compressionRatioRow.querySelector('.text-muted:last-child');
                            if (compressionRatioValue) {
                                // 计算压缩率：优先使用API返回的compression_ratio
                                let ratio = 0;
                                if (task.compression_ratio && task.compression_ratio > 0) {
                                    ratio = task.compression_ratio;
                                } else {
                                    ratio = task.compressed_bytes / task.processed_bytes;
                                }
                                compressionRatioValue.textContent = `${(ratio * 100).toFixed(1)}%`;
                            }
                        } else {
                            // 如果压缩率行不存在，添加它
                            const fileProgressRow = Array.from(taskCard.querySelectorAll('.mb-2 .d-flex.justify-content-between')).find(el => 
                                el.textContent.includes('文件处理进度')
                            );
                            if (fileProgressRow) {
                                const mb2Container = fileProgressRow.parentElement;
                                if (mb2Container) {
                                    let ratio = 0;
                                    if (task.compression_ratio && task.compression_ratio > 0) {
                                        ratio = task.compression_ratio;
                                    } else {
                                        ratio = task.compressed_bytes / task.processed_bytes;
                                    }
                                    const compressionHtml = `
                                        <div class="d-flex justify-content-between">
                                            <small class="text-muted">压缩率:</small>
                                            <small class="text-muted">${(ratio * 100).toFixed(1)}%</small>
                                        </div>
                                    `;
                                    mb2Container.insertAdjacentHTML('beforeend', compressionHtml);
                                }
                            }
                    }
                }
                const totalFilesEl = taskCard.querySelector('.mb-2 .d-flex.justify-content-between');
                if (totalFilesEl && totalFilesEl.textContent.includes('总文件数')) {
                        // 更新总文件数
                        const totalFilesRow = Array.from(taskCard.querySelectorAll('.mb-2 .d-flex.justify-content-between')).find(el => 
                            el.textContent.includes('总文件数')
                        );
                        if (totalFilesRow) {
                            const totalFilesValue = totalFilesRow.querySelector('.text-muted:last-child');
                            if (totalFilesValue) {
                                totalFilesValue.textContent = task.total_files || 0;
                            }
                        }
                        
                        // 更新已处理文件数
                        const processedFilesRow = Array.from(taskCard.querySelectorAll('.mb-2 .d-flex.justify-content-between')).find(el => 
                            el.textContent.includes('已处理')
                        );
                        if (processedFilesRow) {
                            const processedFilesValue = processedFilesRow.querySelector('.text-muted:last-child');
                            if (processedFilesValue) {
                                processedFilesValue.textContent = task.processed_files || 0;
                            }
                        }
                        
                        // 更新压缩率（如果存在）
                        if (task.compressed_bytes > 0) {
                            const compressionRatioRow = Array.from(taskCard.querySelectorAll('.mb-2 .d-flex.justify-content-between')).find(el => 
                                el.textContent.includes('压缩率')
                            );
                            if (compressionRatioRow) {
                                const compressionRatioValue = compressionRatioRow.querySelector('.text-muted:last-child');
                                if (compressionRatioValue) {
                                    const ratio = task.compression_ratio || (task.compressed_bytes / task.processed_bytes);
                                    compressionRatioValue.textContent = `${(ratio * 100).toFixed(1)}%`;
                                }
                            } else {
                                // 如果压缩率行不存在，添加它
                                const mb2Container = compressionRatioRow ? compressionRatioRow.parentElement : totalFilesRow.parentElement;
                                if (mb2Container) {
                                    const ratio = task.compression_ratio || (task.compressed_bytes / task.processed_bytes);
                                    const compressionHtml = `
                                        <div class="d-flex justify-content-between">
                                            <small class="text-muted">压缩率:</small>
                                            <small class="text-muted">${(ratio * 100).toFixed(1)}%</small>
                                        </div>
                                    `;
                                    mb2Container.insertAdjacentHTML('beforeend', compressionHtml);
                                }
                            }
                        }
                    }
                }
            } else {
                // 创建新卡片
                taskCard = document.createElement('div');
                taskCard.className = 'col-md-4 col-lg-4 mb-3';
                taskCard.setAttribute('data-task-id', taskId);
                taskCard.innerHTML = `
                    <div class="service-card">
                        <div class="card-body">
                            <div class="d-flex justify-content-between align-items-start mb-2">
                                <h6 class="card-title mb-0">${task.task_name || '未命名任务'}</h6>
                                <div class="d-flex align-items-center gap-2">
                                    ${statusBadge}
                                    <button class="btn btn-sm btn-outline-danger btn-delete-task" 
                                            data-task-id="${taskId}" 
                                            title="删除任务记录"
                                            style="padding: 0.125rem 0.375rem; line-height: 1;">
                                        <i class="bi bi-trash"></i>
                                    </button>
                                </div>
                            </div>
                            ${getOperationStatus(task.description || '').replace('class="mb-2"', 'class="mb-2 operation-status"')}
                            ${isFailed && task.error_message ? `<div class="mb-2"><small class="text-danger"><i class="bi bi-exclamation-triangle me-1"></i>错误: ${task.error_message.substring(0, 50)}${task.error_message.length > 50 ? '...' : ''}</small></div>` : ''}
                            <div class="mb-2">
                                <small class="text-muted">源路径:</small><br>
                                <code class="text-white">${sourcePaths}</code>
                            </div>
                            <div class="mb-2">
                                <small class="text-muted">目标:</small><br>
                                <code${tapeInfo.includes('\\\\.\\\\scsi') || tapeInfo.includes('\\\\.\\scsi') ? ' class="text-white"' : ''}>${tapeInfo}</code>
                            </div>
                            ${!isFailed ? `
                            <div class="mb-2">
                                <div class="d-flex justify-content-between align-items-center">
                                    <small class="text-muted">进度:</small>
                                    <small class="text-muted">${finalProgress.toFixed(1)}%</small>
                                </div>
                                <div class="progress" style="height: 6px;">
                                    <div class="progress-bar bg-primary" 
                                         role="progressbar" 
                                         style="width: ${finalProgress}%" 
                                         aria-valuenow="${finalProgress}" 
                                         aria-valuemin="0" 
                                         aria-valuemax="100"></div>
                                </div>
                            </div>
                            <div class="mb-2">
                                <div class="d-flex justify-content-between">
                                    <small class="text-muted">文件进度:</small>
                                    <small class="text-muted">${processedFiles}/${totalScannedFiles || processedFiles}</small>
                                </div>
                                <div class="d-flex justify-content-between">
                                    <small class="text-muted">数据量:</small>
                                    <small class="text-muted">${(() => {
                                        const totalBytes = task.total_bytes || 0;  // 独立扫描的文件总大小
                                        const compressedBytes = task.compressed_bytes || 0;  // 压缩后文件大小
                                        
                                        if (compressedBytes > 0 && totalBytes > 0) {
                                            // 显示格式：压缩大小/总大小
                                            return `${formatBytes(compressedBytes)}/${formatBytes(totalBytes)}`;
                                        } else if (totalBytes > 0) {
                                            // 只显示总大小
                                            return formatBytes(totalBytes);
                                        } else {
                                            // 如果没有总大小，显示已处理字节数（向后兼容）
                                            return formatBytes(task.processed_bytes || 0);
                                        }
                                    })()}</small>
                                </div>
                                <div class="d-flex justify-content-between">
                                    <small class="text-muted">已用时间:</small>
                                    <small class="text-muted">${elapsedTime}</small>
                                </div>
                                ${task.compressed_bytes > 0 && parseFloat(compressionRatio) > 0 ? `
                                <div class="d-flex justify-content-between">
                                    <small class="text-muted">压缩率:</small>
                                    <small class="text-muted">${(parseFloat(compressionRatio) * 100).toFixed(1)}%</small>
                                </div>
                                ` : ''}
                            </div>
                            ` : ''}
                            <div class="d-flex justify-content-between">
                                <small class="text-muted">开始时间: ${startedTime}</small>
                            </div>
                            ${isFailed && task.completed_at ? `<div class="mt-2"><small class="text-muted">失败时间: ${formatDateTime(task.completed_at)}</small></div>` : ''}
                        </div>
                    </div>
                `;
                
                // 绑定删除按钮事件
                const deleteBtn = taskCard.querySelector('.btn-delete-task');
                if (deleteBtn) {
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const taskIdToDelete = parseInt(deleteBtn.getAttribute('data-task-id'));
                        deleteTaskRecord(taskIdToDelete);
                    });
                }
                container.appendChild(taskCard);
                runningTaskCards.set(taskId, taskCard);
            }
        });
        
        // 如果没有运行中的任务和最近失败的任务，显示提示
        if (validTasks.length === 0 && runningTaskCards.size === 0) {
            container.innerHTML = '<div class="col-12"><p class="text-muted">暂无运行中的任务和最近失败的任务</p></div>';
        }
        
        // 更新统计数字
        document.getElementById('runningTasks').textContent = validTasks.length;
        
    } catch (error) {
        console.error('加载运行中的任务失败:', error);
        const container = document.getElementById('runningTasksList');
        if (container) {
            container.innerHTML = '<div class="col-12"><p class="text-danger">加载失败: ' + error.message + '</p></div>';
        }
    }
}

// 开始轮询运行中的任务（更频繁的更新）
function startRunningTasksPolling() {
    // 清除之前的轮询
    if (runningTasksPollInterval) {
        clearInterval(runningTasksPollInterval);
    }
    
    // 每2秒更新一次运行中的任务（更频繁的更新以便及时显示操作状态）
    runningTasksPollInterval = setInterval(() => {
        loadRunningTasks();
    }, 2000);
}

// 停止轮询运行中的任务
function stopRunningTasksPolling() {
    if (runningTasksPollInterval) {
        clearInterval(runningTasksPollInterval);
        runningTasksPollInterval = null;
    }
}

// 加载所有任务（包含未运行的计划任务）
async function loadAllTasks() {
    try {
        const statusFilter = document.getElementById('statusFilter')?.value || '';
        const typeFilter = document.getElementById('typeFilter')?.value || '';
        const searchQuery = document.getElementById('searchInput')?.value || '';
        
        let url = '/api/backup/tasks?limit=100&offset=0';
        if (statusFilter) url += `&status=${encodeURIComponent(statusFilter)}`;
        if (typeFilter) url += `&task_type=${encodeURIComponent(typeFilter)}`;
        if (searchQuery) url += `&q=${encodeURIComponent(searchQuery)}`;
        
        const response = await fetch(url);
        const tasks = await response.json();
        
        const tbody = document.getElementById('allTasksTable');
        if (!tbody) return;
        
        tbody.innerHTML = '';
        
        if (tasks && tasks.length > 0) {
            tasks.forEach(task => {
                // 调试：输出任务信息
                console.log('渲染任务:', task.task_id, task.task_name, 'from_scheduler:', task.from_scheduler, 'enabled:', task.enabled);
                
                const sourcePaths = Array.isArray(task.source_paths) ? task.source_paths.join(', ') : (task.source_paths || (task.is_template ? '计划任务' : 'N/A'));
                const row = document.createElement('tr');
                row.className = task.is_template ? 'table-warning' : '';
                row.innerHTML = `
                    <td><strong>${task.task_name || '未命名任务'}</strong>${task.is_template ? ' <span class="badge bg-secondary">模板</span>' : ''}</td>
                    <td>${formatTaskType(task.task_type || 'full')}</td>
                    <td><code class="text-truncate d-inline-block" style="max-width:200px;" title="${sourcePaths}">${sourcePaths}</code></td>
                    <td>${formatStatus(task.status || 'pending', task.description || '')}</td>
                    <td>${formatDateTime(task.started_at)}</td>
                    <td>${formatDateTime(task.completed_at)}</td>
                    <td>${(() => {
                        const totalBytes = task.total_bytes || 0;  // 独立扫描的文件总大小
                        const compressedBytes = task.compressed_bytes || 0;  // 压缩后文件大小
                        
                        if (compressedBytes > 0 && totalBytes > 0) {
                            // 显示格式：压缩大小/总大小
                            return `${formatBytes(compressedBytes)}/${formatBytes(totalBytes)}`;
                        } else if (totalBytes > 0) {
                            // 只显示总大小
                            return formatBytes(totalBytes);
                        } else {
                            // 如果没有总大小，显示已处理字节数（向后兼容）
                            return formatBytes(task.processed_bytes || 0);
                        }
                    })()}</td>
                    <td>
                        <div class="btn-group btn-group-sm" data-task-id="${task.task_id}" data-from-scheduler="${task.from_scheduler ? 'true' : 'false'}" data-enabled="${task.enabled !== false ? 'true' : 'false'}">
                            ${task.from_scheduler ? `
                                ${task.enabled === false ? `
                                    <button class="btn btn-outline-success btn-action-enable" title="启用">
                                        <i class="bi bi-play"></i>
                                    </button>
                                ` : `
                                    <button class="btn btn-outline-warning btn-action-disable" title="禁用">
                                        <i class="bi bi-pause"></i>
                                    </button>
                                `}
                                <button class="btn btn-outline-info btn-action-run" title="立即运行">
                                    <i class="bi bi-play-circle"></i>
                                </button>
                                <button class="btn btn-outline-secondary btn-action-unlock" title="解锁">
                                    <i class="bi bi-unlock"></i>
                                </button>
                            ` : `
                                <button class="btn btn-outline-warning" title="禁用" disabled>
                                    <i class="bi bi-pause"></i>
                                </button>
                                <button class="btn btn-outline-info" title="立即运行" disabled>
                                    <i class="bi bi-play-circle"></i>
                                </button>
                            `}
                            <button class="btn btn-outline-primary btn-action-edit" title="编辑">
                                <i class="bi bi-pencil"></i>
                            </button>
                            <button class="btn btn-outline-danger btn-action-delete" title="删除">
                                <i class="bi bi-trash"></i>
                            </button>
                        </div>
                    </td>
                `;
                tbody.appendChild(row);
            });
        } else {
            tbody.innerHTML = '<tr><td colspan="8" class="text-center text-muted">暂无任务</td></tr>';
        }
    } catch (error) {
        console.error('加载所有任务失败:', error);
        const tbody = document.getElementById('allTasksTable');
        if (tbody) {
            tbody.innerHTML = '<tr><td colspan="8" class="text-center text-danger">加载失败: ' + error.message + '</td></tr>';
        }
    }
}


// 查看任务详情
function viewTaskDetails(taskId) {
    // TODO: 实现查看任务详情
    console.log('查看任务详情:', taskId);
}

// 下载备份
function downloadBackup(taskId) {
    // TODO: 实现下载备份
    console.log('下载备份:', taskId);
}

// 重试任务
function retryTask(taskId) {
    // TODO: 实现重试任务
    console.log('重试任务:', taskId);
}

// 禁用备份任务（计划任务）
async function disableBackupTask(taskId) {
    if (!confirm('确定要禁用此计划任务吗？')) {
        return;
    }
    try {
        const response = await fetch(`/api/scheduler/tasks/${taskId}/disable`, {
            method: 'POST'
        });
        const result = await response.json();
        if (result.success) {
            alert('任务已禁用');
            loadAllTasks();
        } else {
            alert('禁用失败: ' + (result.message || '未知错误'));
        }
    } catch (error) {
        console.error('禁用任务失败:', error);
        alert('禁用失败: ' + error.message);
    }
}

// 启用备份任务（计划任务）
async function enableBackupTask(taskId) {
    if (!confirm('确定要启用此计划任务吗？')) {
        return;
    }
    try {
        const response = await fetch(`/api/scheduler/tasks/${taskId}/enable`, {
            method: 'POST'
        });
        const result = await response.json();
        if (result.success) {
            alert('任务已启用');
            loadAllTasks();
        } else {
            alert('启用失败: ' + (result.message || '未知错误'));
        }
    } catch (error) {
        console.error('启用任务失败:', error);
        alert('启用失败: ' + error.message);
    }
}

// 运行备份任务（计划任务）
// 扫描进度条相关变量
let scanProgressInterval = null;
let currentScanTaskId = null;

// 显示扫描进度条
function showScanProgressModal(taskId) {
    currentScanTaskId = taskId;
    const modal = document.getElementById('scanProgressModal');
    if (!modal) {
        // 创建进度条模态框
        const modalHtml = `
            <div class="modal fade" id="scanProgressModal" tabindex="-1" aria-labelledby="scanProgressModalLabel" aria-hidden="true" data-bs-backdrop="static" data-bs-keyboard="false">
                <div class="modal-dialog modal-dialog-centered">
                    <div class="modal-content bg-dark text-light">
                        <div class="modal-header border-secondary">
                            <h5 class="modal-title" id="scanProgressModalLabel">
                                <i class="bi bi-hourglass-split me-2"></i>正在扫描文件...
                            </h5>
                        </div>
                        <div class="modal-body">
                            <div class="mb-3">
                                <div class="d-flex justify-content-between mb-2">
                                    <span id="scanProgressText">扫描中...</span>
                                    <span id="scanProgressPercent">0%</span>
                                </div>
                                <div class="progress" style="height: 25px;">
                                    <div class="progress-bar progress-bar-striped progress-bar-animated bg-primary" 
                                         role="progressbar" 
                                         id="scanProgressBar" 
                                         style="width: 0%"
                                         aria-valuenow="0" 
                                         aria-valuemin="0" 
                                         aria-valuemax="100">
                                    </div>
                                </div>
                            </div>
                            <div class="text-muted small">
                                <div id="scanProgressDetails">
                                    <div>已扫描: <span id="scanScannedCount">0</span> 个文件</div>
                                    <div>有效文件: <span id="scanValidCount">0</span> 个</div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer border-secondary">
                            <button type="button" class="btn btn-secondary" id="scanProgressCancelBtn" onclick="hideScanProgressModal()">取消</button>
                        </div>
                    </div>
                </div>
            </div>
        `;
        document.body.insertAdjacentHTML('beforeend', modalHtml);
    }
    
    // 重置进度条
    document.getElementById('scanProgressBar').style.width = '0%';
    document.getElementById('scanProgressBar').setAttribute('aria-valuenow', '0');
    document.getElementById('scanProgressPercent').textContent = '0%';
    document.getElementById('scanScannedCount').textContent = '0';
    document.getElementById('scanValidCount').textContent = '0';
    document.getElementById('scanProgressText').textContent = '正在扫描源文件...';
    
    // 显示模态框
    const bsModal = new bootstrap.Modal(document.getElementById('scanProgressModal'));
    bsModal.show();
    
    // 开始轮询进度
    startScanProgressPolling(taskId);
}

// 隐藏扫描进度条
function hideScanProgressModal() {
    stopScanProgressPolling();
    const modal = document.getElementById('scanProgressModal');
    if (modal) {
        const bsModal = bootstrap.Modal.getInstance(modal);
        if (bsModal) {
            bsModal.hide();
        }
    }
    currentScanTaskId = null;
}

// 开始轮询扫描进度
function startScanProgressPolling(taskId) {
    // 清除之前的轮询
    stopScanProgressPolling();
    
    // 每500ms轮询一次
    scanProgressInterval = setInterval(async () => {
        try {
            const response = await fetch(`/api/backup/tasks/${taskId}/status`);
            if (!response.ok) {
                throw new Error('获取任务状态失败');
            }
            const status = await response.json();
            
            // 更新进度条
            const progress = status.progress_percent || 0;
            document.getElementById('scanProgressBar').style.width = progress + '%';
            document.getElementById('scanProgressBar').setAttribute('aria-valuenow', progress);
            document.getElementById('scanProgressPercent').textContent = progress.toFixed(1) + '%';
            document.getElementById('scanScannedCount').textContent = status.processed_files || 0;
            document.getElementById('scanValidCount').textContent = status.total_files || 0;
            
            // 如果任务状态不是运行中，停止轮询
            if (status.status !== 'running') {
                if (status.status === 'completed') {
                    document.getElementById('scanProgressText').textContent = '扫描完成！';
                    setTimeout(() => {
                        hideScanProgressModal();
                    }, 1000);
                } else if (status.status === 'failed') {
                    document.getElementById('scanProgressText').textContent = '扫描失败: ' + (status.error_message || '未知错误');
                    setTimeout(() => {
                        hideScanProgressModal();
                    }, 3000);
                } else {
                    hideScanProgressModal();
                }
            }
        } catch (error) {
            console.error('获取扫描进度失败:', error);
            // 不中断轮询，继续尝试
        }
    }, 500);
}

// 停止轮询扫描进度
function stopScanProgressPolling() {
    if (scanProgressInterval) {
        clearInterval(scanProgressInterval);
        scanProgressInterval = null;
    }
}

async function runBackupTask(taskId) {
    if (!confirm('确定要立即运行此计划任务吗？')) {
        return;
    }
    try {
        // 显示扫描进度条
        showScanProgressModal(taskId);
        
        const response = await fetch(`/api/scheduler/tasks/${taskId}/run`, {
            method: 'POST'
        });
        const result = await response.json();
        if (result.success) {
            // 不立即关闭进度条，等待轮询检测任务完成
            loadAllTasks();
            loadRunningTasks();
        } else {
            hideScanProgressModal();
            alert('运行失败: ' + (result.message || '未知错误'));
        }
    } catch (error) {
        console.error('运行任务失败:', error);
        hideScanProgressModal();
        alert('运行失败: ' + error.message);
    }
}

// 编辑备份任务
async function editBackupTask(taskId, isScheduler) {
    // 确保 SchedulerManager 已加载
    if (!window.SchedulerManager) {
        // 动态加载 SchedulerManager
        try {
            const module = await import('/static/js/modules/system/scheduler.js');
            window.SchedulerManager = module.SchedulerManager;
        } catch (error) {
            console.error('加载 SchedulerManager 失败:', error);
            alert('无法加载计划任务管理器，请刷新页面重试');
            return;
        }
    }
    
    if (isScheduler === true || isScheduler === 'true') {
        // 直接调用计划任务的编辑功能
        window.SchedulerManager.editTask(taskId);
        return;
    }
    
    // 备份任务模板：转换为计划任务格式并填充表单
    try {
        let backupTask;
        try {
            // 尝试获取备份任务详情
            const response = await fetch(`/api/backup/tasks/${taskId}`);
            if (!response.ok) {
                // 如果404，说明可能是计划任务的ID，尝试直接编辑计划任务
                if (response.status === 404) {
                    console.log('备份任务不存在，尝试作为计划任务编辑:', taskId);
                    window.SchedulerManager.editTask(taskId);
                    return;
                }
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            backupTask = await response.json();
        } catch (error) {
            // 如果获取失败，尝试作为计划任务编辑
            console.log('获取备份任务失败，尝试作为计划任务编辑:', error);
            try {
                window.SchedulerManager.editTask(taskId);
                return;
            } catch (schedError) {
                console.error('编辑计划任务也失败:', schedError);
                throw error;
            }
        }
        
        // 尝试通过任务名称查找计划任务
        try {
            const schedResponse = await fetch(`/api/scheduler/tasks`);
            const schedTasks = await schedResponse.json();
            const matchingTask = schedTasks.find(t => t.task_name === backupTask.task_name);
            
            if (matchingTask) {
                // 找到对应的计划任务，直接编辑
                window.SchedulerManager.editTask(matchingTask.id);
                return;
            }
        } catch (error) {
            console.log('查找计划任务失败，将使用备份任务模板数据:', error);
        }
        
        // 没有对应的计划任务，将备份任务模板转换为计划任务格式
        const sourcePaths = backupTask.source_paths || [];
        const excludePatterns = Array.isArray(backupTask.exclude_patterns) 
            ? backupTask.exclude_patterns 
            : (backupTask.exclude_patterns ? backupTask.exclude_patterns.split('\n') : []);
        
        // 构建计划任务格式的数据
        const schedulerTaskData = {
            id: null, // 新建任务
            task_name: backupTask.task_name || '',
            description: backupTask.description || '',
            schedule_type: 'once', // 默认一次性任务
            schedule_config: {
                datetime: new Date().toISOString().replace('T', ' ').substring(0, 19)
            },
            action_type: 'backup',
            action_config: {
                source_paths: sourcePaths,
                task_type: backupTask.task_type || 'full',
                tape_device: backupTask.tape_device || null,
                target_type: backupTask.tape_device ? 'tape' : 'storage',
                tape_devices: backupTask.tape_device ? [backupTask.tape_device] : [],
                compression_enabled: backupTask.compression_enabled !== false,
                encryption_enabled: backupTask.encryption_enabled === true,
                exclude_patterns: excludePatterns
            },
            enabled: true
        };
        
        // 填充表单并打开模态框
        window.SchedulerManager.fillForm(schedulerTaskData);
        window.SchedulerManager.currentTask = null; // 标记为新建任务
        
        const modal = new bootstrap.Modal(document.getElementById('scheduledTaskModal'));
        modal.show();
    } catch (error) {
        console.error('编辑备份任务失败:', error);
        alert('编辑失败: ' + error.message);
    }
}

// 删除备份任务
async function deleteBackupTask(taskId, isScheduler) {
    if (!confirm('确定要删除此任务吗？此操作不可恢复！')) {
        return;
    }
    try {
        if (isScheduler) {
            // 删除计划任务
            const response = await fetch(`/api/scheduler/tasks/${taskId}`, {
                method: 'DELETE'
            });
            const result = await response.json();
            if (result.success) {
                alert('任务已删除');
                loadAllTasks();
            } else {
                alert('删除失败: ' + (result.message || '未知错误'));
            }
        } else {
            // 删除备份任务模板或执行记录
            const response = await fetch(`/api/backup/tasks/${taskId}`, {
                method: 'DELETE'
            });
            const result = await response.json();
            if (result.success) {
                alert(result.message || '任务已删除');
                loadAllTasks();
                loadRunningTasks(); // 刷新运行中的任务列表
            } else {
                alert('删除失败: ' + (result.message || '未知错误'));
            }
        }
    } catch (error) {
        console.error('删除任务失败:', error);
        alert('删除失败: ' + error.message);
    }
}

// 删除任务记录（用于运行中的任务卡片）
async function deleteTaskRecord(taskId) {
    if (!confirm('确定要删除此任务记录吗？此操作不可恢复！\n注意：如果任务正在运行，删除操作不会停止任务执行。')) {
        return;
    }
    try {
        const response = await fetch(`/api/backup/tasks/${taskId}`, {
            method: 'DELETE'
        });
        
        // 检查HTTP状态码
        if (!response.ok) {
            let errorMessage = '删除失败';
            try {
                const errorData = await response.json();
                errorMessage = errorData.detail || errorData.message || errorMessage;
            } catch (e) {
                errorMessage = `HTTP ${response.status}: ${response.statusText}`;
            }
            alert(errorMessage);
            return;
        }
        
        const result = await response.json();
        if (result.success || result.message) {
            // 从运行中的任务卡片中移除
            const taskCard = runningTaskCards.get(taskId);
            if (taskCard) {
                taskCard.remove();
                runningTaskCards.delete(taskId);
            }
            // 刷新列表
            loadAllTasks();
            loadRunningTasks();
            // 不显示alert，静默删除
        } else {
            alert('删除失败: ' + (result.message || '未知错误'));
        }
    } catch (error) {
        console.error('删除任务记录失败:', error);
        alert('删除失败: ' + (error.message || '网络错误'));
    }
}

// 页面加载时加载数据
document.addEventListener('DOMContentLoaded', async function() {
    // 确保 SchedulerManager 已加载
    if (!window.SchedulerManager) {
        try {
            const module = await import('/static/js/modules/system/scheduler.js');
            window.SchedulerManager = module.SchedulerManager;
            // 初始化 SchedulerManager（但不加载任务列表）
            if (!window.SchedulerManager.initialized) {
                await window.SchedulerManager.loadTapeDevices();
                window.SchedulerManager.setupEventListeners();
                window.SchedulerManager.setupActionTypeChange();
                window.SchedulerManager.setupDatePickers();
                window.SchedulerManager.setupDirectoryBrowsers();
                window.SchedulerManager.initialized = true;
            }
        } catch (error) {
            console.error('加载 SchedulerManager 失败:', error);
        }
    }
    
    loadBackupStatistics();
    loadRunningTasks();
    loadAllTasks();
    
    // 开始轮询运行中的任务（更频繁的更新）
    startRunningTasksPolling();
    
    // 绑定筛选和搜索事件
    const statusFilter = document.getElementById('statusFilter');
    const typeFilter = document.getElementById('typeFilter');
    const searchInput = document.getElementById('searchInput');
    const searchBtn = document.getElementById('searchBtn');
    
    if (statusFilter) {
        statusFilter.addEventListener('change', loadAllTasks);
    }
    if (typeFilter) {
        typeFilter.addEventListener('change', loadAllTasks);
    }
    if (searchInput) {
        searchInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                loadAllTasks();
            }
        });
    }
    if (searchBtn) {
        searchBtn.addEventListener('click', loadAllTasks);
    }
    
    // 绑定操作按钮事件（使用事件委托，绑定到document，确保动态生成的按钮也能响应）
    document.addEventListener('click', function(e) {
        // 检查点击是否在任务表格中
        const tbody = document.getElementById('allTasksTable');
        if (!tbody || !tbody.contains(e.target)) return;
        
        // 处理点击图标或按钮的情况
        let btn = e.target;
        if (btn.tagName === 'I' || btn.tagName === 'i') {
            // 如果点击的是图标，找父元素按钮
            btn = btn.closest('button');
        } else if (btn.tagName !== 'BUTTON') {
            // 如果点击的不是按钮，尝试找最近的按钮
            btn = btn.closest('button');
        }
        
        if (!btn) return;
        
        // 检查按钮是否有操作类名
        if (!btn.classList.contains('btn-action-enable') && 
            !btn.classList.contains('btn-action-disable') && 
            !btn.classList.contains('btn-action-run') && 
            !btn.classList.contains('btn-action-unlock') && 
            !btn.classList.contains('btn-action-edit') && 
            !btn.classList.contains('btn-action-delete')) {
            return;
        }
        
        const btnGroup = btn.closest('.btn-group');
        if (!btnGroup) {
            console.warn('无法找到按钮组');
            return;
        }
        
        const taskId = parseInt(btnGroup.dataset.taskId);
        if (!taskId || isNaN(taskId)) {
            console.warn('无法获取任务ID:', btnGroup.dataset);
            return;
        }
        
        const fromScheduler = btnGroup.dataset.fromScheduler === 'true';
        const enabled = btnGroup.dataset.enabled === 'true';
        
        // 阻止默认行为
        e.preventDefault();
        e.stopPropagation();
        
        console.log('点击按钮:', btn.className, '任务ID:', taskId, 'from_scheduler:', fromScheduler);
        
        // 根据按钮类名执行对应操作
        if (btn.classList.contains('btn-action-enable')) {
            console.log('执行启用操作，任务ID:', taskId);
            enableBackupTask(taskId);
        } else if (btn.classList.contains('btn-action-disable')) {
            console.log('执行禁用操作，任务ID:', taskId);
            disableBackupTask(taskId);
        } else if (btn.classList.contains('btn-action-run')) {
            console.log('执行运行操作，任务ID:', taskId);
            runBackupTask(taskId);
        } else if (btn.classList.contains('btn-action-unlock')) {
            console.log('执行解锁操作，任务ID:', taskId);
            if (fromScheduler) {
                fetch(`/api/scheduler/tasks/${taskId}/unlock`, { method: 'POST' })
                    .then(async (response) => {
                        const result = await response.json();
                        if (result.success) {
                            alert('解锁成功：' + (result.message || '任务已解锁'));
                        } else {
                            alert('解锁失败：' + (result.message || '未知错误'));
                        }
                    })
                    .catch((error) => {
                        console.error('解锁失败:', error);
                        alert('解锁失败：' + (error.message || '网络错误'));
                    });
            } else {
                alert('仅计划任务支持解锁');
            }
        } else if (btn.classList.contains('btn-action-edit')) {
            console.log('执行编辑操作，任务ID:', taskId, 'from_scheduler:', fromScheduler);
            editBackupTask(taskId, fromScheduler);
        } else if (btn.classList.contains('btn-action-delete')) {
            console.log('执行删除操作，任务ID:', taskId, 'from_scheduler:', fromScheduler);
            deleteBackupTask(taskId, fromScheduler);
        }
    });
    
    // 每30秒刷新一次统计和所有任务列表（运行中的任务由单独的轮询处理）
    setInterval(function() {
        loadBackupStatistics();
        loadAllTasks();
        // 注意：loadRunningTasks() 由 startRunningTasksPolling() 每5秒调用一次
    }, 30000);
    
    // 页面卸载时停止轮询
    window.addEventListener('beforeunload', function() {
        stopRunningTasksPolling();
    });
});
</script>

{% endblock %}