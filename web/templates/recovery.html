{% extends "base.html" %}

{% block title %}{{ app_name }} - 数据恢复{% endblock %}

{% block extra_css %}
<style>
:root { --recoveryPaneHeight: 1200px; }
.backup-set-card {
    transition: all 0.3s ease;
    border-left: 4px solid transparent;
}
.backup-set-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}
.backup-set-full { border-left-color: #28a745; }
.backup-set-incremental { border-left-color: #007bff; }
.backup-set-differential { border-left-color: #ffc107; }

.file-tree {
    min-height: 600px;
    max-height: var(--recoveryPaneHeight);
    height: 600px;
    overflow-y: auto;
    border: 1px solid rgba(0, 170, 255, 0.2);
    border-radius: 4px;
    padding: 8px;
    background: rgba(13, 22, 38, 0.7);
    color: var(--text-primary);
}

/* 文件树滚动条样式 */
.file-tree::-webkit-scrollbar {
    width: 8px;
}
.file-tree::-webkit-scrollbar-track {
    background: rgba(13, 22, 38, 0.5);
    border-radius: 4px;
}
.file-tree::-webkit-scrollbar-thumb {
    background: rgba(0, 170, 255, 0.3);
    border-radius: 4px;
}
.file-tree::-webkit-scrollbar-thumb:hover {
    background: rgba(0, 170, 255, 0.5);
}

/* 文件树内的提示文本样式 */
.file-tree .text-center.text-muted {
    color: var(--text-secondary) !important;
}

.file-tree .alert {
    background: rgba(13, 22, 38, 0.8);
    border-color: rgba(0, 170, 255, 0.3);
    color: var(--text-primary);
}

.file-tree .alert-danger {
    background: rgba(255, 85, 119, 0.2);
    border-color: var(--danger);
    color: var(--danger);
}

/* 确保恢复页面有足够的高度 */
.console-panel {
    min-height: calc(100vh - 200px);
}

/* 文件浏览器区域 */
.service-card .card-body {
    min-height: 600px;
}

.tree-node {
    padding: 4px 8px;
    cursor: pointer;
    transition: background-color 0.2s;
    color: var(--text-primary);
    border-radius: 4px;
    margin: 2px 0;
}
.tree-node:hover {
    background-color: rgba(0, 170, 255, 0.15);
    color: var(--primary-light);
}
.tree-node.selected {
    background-color: rgba(0, 170, 255, 0.25);
    color: var(--primary-light);
}

/* 树节点文本颜色 */
.tree-node span {
    color: var(--text-primary);
}
.tree-node:hover span {
    color: var(--primary-light);
}
.tree-node.selected span {
    color: var(--primary-light);
}

/* 树节点小文本（文件大小） */
.tree-node small {
    color: var(--text-secondary);
}
.tree-node:hover small {
    color: var(--text-secondary);
}

/* 树节点图标颜色 */
.tree-node i {
    color: var(--text-secondary);
}
.tree-node:hover i {
    color: var(--primary-light);
}
.tree-node.selected i {
    color: var(--primary-light);
}

/* 复选框样式 */
.tree-node input[type="checkbox"] {
    accent-color: var(--primary);
}

/* 展开/折叠按钮颜色 */
.tree-toggle {
    color: var(--text-secondary);
}
.tree-toggle:hover {
    color: var(--primary-light);
}
</style>
{% endblock %}

{% block content %}
<div class="console-panel">
    <div class="d-flex justify-content-between align-items-center mb-4">
        <h5 class="mb-0">
            <i class="bi bi-cloud-download me-2"></i>数据恢复
        </h5>
        <button class="btn btn-success" id="startRecoveryBtn" disabled>
            <i class="bi bi-play-circle me-2"></i>开始恢复
        </button>
    </div>

    <div class="row">
        <!-- 备份集时间轴 -->
        <div class="col-lg-4">
            <div class="service-card">
                <div class="card-body">
                    <h6 class="mb-2">
                        <i class="bi bi-calendar-event me-2"></i>
                        备份集时间轴
                    </h6>
                    <!-- 当前备份集信息（移动到时间轴区域） -->
                    <div class="alert alert-info py-2 mb-3">
                        <strong>当前备份集:</strong>
                        <span id="currentBackupName">完整备份 (2025-10-01 02:00)</span>
                        <button class="btn btn-sm btn-outline-secondary float-end" id="changeBackupBtn">
                            <i class="bi bi-arrow-left-right me-1"></i>切换
                        </button>
                    </div>
                    <!-- 月份选择 -->
                    <div class="mb-3">
                        <select class="form-select" id="monthSelect">
                            <option value="">加载中...</option>
                        </select>
                    </div>

                    <!-- 备份集列表 -->
                    <div class="backup-timeline">
                        <div class="text-center text-muted py-5">
                            <i class="bi bi-hourglass-split me-2"></i>正在加载备份集...
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 文件浏览器 -->
        <div class="col-lg-8">
            <div class="service-card">
                <div class="card-body">
                    <h6 class="mb-3">
                        <i class="bi bi-folder-open me-2"></i>
                        文件浏览器
                    </h6>
                    <!-- 当前备份集信息已移动到左侧时间轴区域 -->

                    <!-- 搜索和筛选 -->
                    <div class="row mb-3">
                        <div class="col-md-8">
                            <div class="input-group">
                                <input type="text" class="form-control" placeholder="搜索文件或文件夹..." id="fileSearch">
                                <button class="btn btn-outline-secondary" type="button">
                                    <i class="bi bi-search"></i>
                                </button>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <select class="form-select" id="fileTypeFilter">
                                <option>所有文件</option>
                                <option>仅显示文件</option>
                                <option>仅显示文件夹</option>
                            </select>
                        </div>
                    </div>

                    <!-- 文件树 -->
                    <div class="file-tree" id="fileTree">
                        <div class="text-center text-muted py-5">
                            <i class="bi bi-info-circle me-2"></i>请先选择备份集
                        </div>
                    </div>

                    <!-- 选中文件统计 -->
                    <div class="mt-3 p-3 service-card rounded">
                        <div class="row">
                            <div class="col-md-3">
                                <strong>选中文件:</strong>
                                <span class="text-primary" id="selectedCount">0</span>
                            </div>
                            <div class="col-md-3">
                                <strong>总大小:</strong>
                                <span id="selectedSize">0 KB</span>
                            </div>
                            <div class="col-md-3">
                                <strong>包含文件夹:</strong>
                                <span id="folderCount">0</span>
                            </div>
                            <div class="col-md-3">
                                <button class="btn btn-sm btn-outline-primary" id="selectAllBtn">
                                    <i class="bi bi-check-square me-1"></i>全选
                                </button>
                                <button class="btn btn-sm btn-outline-secondary" id="clearSelectionBtn">
                                    <i class="bi bi-x-circle me-1"></i>清除
                                </button>
                            </div>
                        </div>
                        <!-- 选中文件列表 -->
                        <div class="mt-3">
                            <div class="list-group" id="selectedFilesList" style="max-height: var(--recoveryPaneHeight); overflow-y: auto;"></div>
                        </div>
                    </div>

                    <!-- 恢复选项 -->
                    <hr class="my-4">
                    <h6 class="mb-3">
                        <i class="bi bi-gear me-2"></i>
                        恢复选项
                    </h6>
                    <div class="row">
                        <div class="col-md-6">
                            <label class="form-label">恢复目标路径 <small class="text-muted ms-2">文件将恢复到此目录</small></label>
                            <div class="input-group">
                                <input type="text" class="form-control" value="/tmp/recovery" id="recoveryPath">
                                <button class="btn btn-outline-secondary" type="button" id="browseRecoveryPathBtn">
                                    <i class="bi bi-folder2-open me-1"></i>浏览
                                </button>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <label class="form-label">覆盖选项</label>
                            <select class="form-select" id="overwriteOption">
                                <option value="ask">询问是否覆盖</option>
                                <option value="skip">跳过已存在的文件</option>
                                <option value="overwrite">覆盖所有文件</option>
                            </select>
                        </div>
                    </div>
                    <div class="row mt-3">
                        <div class="col-md-4">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="preservePerms" checked>
                                <label class="form-check-label" for="preservePerms">保留文件权限</label>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="verifyIntegrity" checked>
                                <label class="form-check-label" for="verifyIntegrity">验证文件完整性</label>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="sendNotification" checked>
                                <label class="form-check-label" for="sendNotification">发送完成通知</label>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
.backup-timeline {
    flex: 1;
    overflow-y: auto;
    max-height: var(--recoveryPaneHeight);
    margin-left: -25px;
    margin-right: -25px;
    padding-left: 25px;
    padding-right: 25px;
}

.backup-set-card {
    cursor: pointer;
    background: var(--card-bg);
    color: var(--text-primary);
}
.backup-set-card.selected {
    background-color: rgba(0, 170, 255, 0.2) !important;
    border-color: var(--primary) !important;
    border-width: 2px !important;
    color: var(--text-primary) !important;
}
.backup-set-card.selected h6,
.backup-set-card.selected small,
.backup-set-card.selected span,
.backup-set-card.selected .badge {
    color: var(--text-primary) !important;
}

/* 目录树竖向展示样式 */
.tree-node {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    padding: 2px 0;
    margin: 0;
    color: var(--text-primary);
    width: 100%;
    box-sizing: border-box;
}

/* 节点内容行（横向） */
.tree-node > div:first-child {
    display: flex;
    align-items: center;
    width: 100%;
    padding: 4px 8px;
    border-radius: 4px;
    transition: background-color 0.2s;
}

.tree-node:hover > div:first-child {
    background-color: rgba(0, 170, 255, 0.15);
    color: var(--primary-light);
}

.tree-node.selected > div:first-child {
    background-color: rgba(0, 170, 255, 0.25);
    color: var(--primary-light);
}

.tree-node.expanded > .tree-toggle {
    transform: rotate(90deg);
}

.tree-toggle {
    width: 16px;
    height: 16px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    margin-right: 4px;
    cursor: pointer;
    transition: transform 0.2s, color 0.2s;
    color: var(--text-secondary);
    flex-shrink: 0;
}

.tree-toggle:hover {
    color: var(--primary-light);
}

/* 子节点容器 - 竖向排列，通过左侧缩进显示层级 */
.tree-children {
    display: none;
    width: 100%;
    padding-left: 20px;
    margin-left: 0;
    box-sizing: border-box;
    position: relative;
}

/* 子节点左侧连接线 */
.tree-children::before {
    content: '';
    position: absolute;
    left: 8px;
    top: 0;
    bottom: 0;
    width: 1px;
    background: rgba(0, 170, 255, 0.2);
}

.tree-node.expanded > .tree-children {
    display: block;
}

/* 确保所有层级的节点都是竖向排列 */
.tree-children .tree-node {
    width: 100%;
    margin: 0;
    padding: 0;
}

.tree-node.leaf > .tree-toggle {
    visibility: hidden;
    width: 16px;
}

/* 节点内容区域 */
.tree-node-content {
    display: flex;
    align-items: center;
    width: 100%;
    flex: 1;
    min-width: 0;
}

/* 文件名和大小 */
.tree-node-content > span:not(.tree-toggle):not(small) {
    flex: 1;
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.tree-node-content > small {
    flex-shrink: 0;
    margin-left: auto;
}
</style>
<script>
// 恢复页文件树与选中列表联动
(function() {
    const treeRoot = document.getElementById('fileTree');
    if (!treeRoot) return;

    const selectedCountEl = document.getElementById('selectedCount');
    const selectedSizeEl = document.getElementById('selectedSize');
    const folderCountEl = document.getElementById('folderCount');
    const listEl = document.getElementById('selectedFilesList');
    const selectAllBtn = document.getElementById('selectAllBtn');
    const clearSelectionBtn = document.getElementById('clearSelectionBtn');
    const monthSelect = document.getElementById('monthSelect');
    const changeBackupBtn = document.getElementById('changeBackupBtn');
    const timeline = document.querySelector('.backup-timeline');
    const currentBackupNameEl = document.getElementById('currentBackupName');
    const startRecoveryBtn = document.getElementById('startRecoveryBtn');
    const fileSearch = document.getElementById('fileSearch');
    const fileTypeFilter = document.getElementById('fileTypeFilter');

    let autoId = 1;
    const fileIndex = new Map(); // id -> {el,type,sizeBytes,children:[],name}
    const selectedFiles = new Set(); // only files
    const selectedFolders = new Set();
    let currentBackupSetId = null;
    // 注意：已改为按需加载，不再存储所有文件数据

    // 格式化字节大小
    function formatBytes(b){
        const units = ['B','KB','MB','GB','TB'];
        let i=0; let v=b;
        while (v>=1024 && i<units.length-1){ v/=1024; i++; }
        return (i===0? v : v.toFixed(1)) + ' ' + units[i];
    }

    function bytesFromText(txt){
        if (!txt) return 0;
        const m = String(txt).trim().match(/([0-9]+(?:\.[0-9]+)?)\s*(KB|MB|GB|TB|B)/i);
        if (!m) return 0;
        const n = parseFloat(m[1]);
        const unit = m[2].toUpperCase();
        const mul = {B:1, KB:1024, MB:1024**2, GB:1024**3, TB:1024**4}[unit]||1;
        return Math.round(n*mul);
    }

    // 从API加载备份组列表
    async function loadBackupGroups() {
        try {
            const response = await fetch('/api/recovery/backup-groups');
            const data = await response.json();
            const groups = data.backup_groups || [];
            
            // 更新月份选择下拉框
            monthSelect.innerHTML = '';
            groups.forEach(group => {
                const option = document.createElement('option');
                const [year, month] = group.split('-');
                option.value = group;
                option.textContent = `${year}年${parseInt(month)}月`;
                monthSelect.appendChild(option);
            });
            
            // 默认选择第一个月份
            if (groups.length > 0) {
                monthSelect.value = groups[0];
                await loadBackupSets(groups[0]);
            }
        } catch (error) {
            console.error('加载备份组失败:', error);
        }
    }

    // 从API加载备份集列表
    async function loadBackupSets(backupGroup) {
        try {
            const response = await fetch(`/api/recovery/backup-sets?backup_group=${encodeURIComponent(backupGroup)}`);
            const data = await response.json();
            const backupSets = data.backup_sets || [];
            
            // 清空时间轴
            timeline.innerHTML = '';
            
            if (backupSets.length === 0) {
                timeline.innerHTML = '<div class="alert alert-info">该月份暂无备份集</div>';
                return;
            }
            
            // 渲染备份集卡片
            backupSets.forEach(backupSet => {
                const card = document.createElement('div');
                card.className = `backup-set-card backup-set-${getBackupTypeClass(backupSet.backup_type)} mb-3 p-3`;
                card.dataset.backupId = backupSet.set_id;
                
                const backupTime = new Date(backupSet.backup_time);
                const timeStr = backupTime.toLocaleString('zh-CN', { 
                    year: 'numeric', month: '2-digit', day: '2-digit', 
                    hour: '2-digit', minute: '2-digit' 
                });
                
                card.innerHTML = `
                    <div class="d-flex justify-content-between align-items-start">
                        <div class="flex-grow-1" style="cursor: pointer;">
                            <h6 class="mb-1">${getBackupTypeName(backupSet.backup_type)}</h6>
                            <small class="text-muted">${timeStr}</small>
                            <div class="mt-2">
                                <small class="text-muted">磁带: </small>
                                <span class="badge bg-secondary">${backupSet.tape_id || 'N/A'}</span>
                            </div>
                            <div class="mt-1">
                                <small class="text-muted">大小: </small>
                                <span>${formatBytes(backupSet.total_bytes || 0)}</span>
                            </div>
                        </div>
                        <div class="text-end">
                            <span class="badge ${getBackupTypeBadge(backupSet.backup_type)}">${getBackupTypeShortName(backupSet.backup_type)}</span>
                            <button class="btn btn-sm btn-outline-danger mt-2" onclick="event.stopPropagation(); deleteBackupSet('${backupSet.set_id}')" title="删除备份集">
                                <i class="bi bi-trash"></i>
                            </button>
                        </div>
                    </div>
                `;
                
                // 点击选择备份集
                card.addEventListener('click', function(e) {
                    // 如果点击的是删除按钮，不触发选择
                    if (e.target.closest('button')) {
                        return;
                    }
                    timeline.querySelectorAll('.backup-set-card.selected').forEach(c=>c.classList.remove('selected'));
                    this.classList.add('selected');
                    currentBackupSetId = backupSet.set_id;
                    const title = this.querySelector('h6')?.textContent?.trim() || '';
                    const time = this.querySelector('small.text-muted')?.textContent?.trim() || '';
                    if (currentBackupNameEl){ 
                        currentBackupNameEl.textContent = title + (time? ' ('+time+')':''); 
                    }
                    loadBackupSetFiles(backupSet.set_id);
                });
                
                timeline.appendChild(card);
            });
            
            // 默认选择第一个备份集
            if (backupSets.length > 0) {
                const firstCard = timeline.querySelector('.backup-set-card');
                if (firstCard) {
                    firstCard.click();
                }
            }
        } catch (error) {
            console.error('加载备份集失败:', error);
            timeline.innerHTML = '<div class="alert alert-danger">加载备份集失败: ' + error.message + '</div>';
        }
    }

    // 删除备份集
    async function deleteBackupSet(setId) {
        if (!confirm(`确定要删除备份集 ${setId} 吗？\n\n此操作将删除备份集及其所有文件记录，且不可恢复！`)) {
            return;
        }
        
        try {
            const response = await fetch(`/api/backup/backup-sets/${encodeURIComponent(setId)}`, {
                method: 'DELETE'
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ detail: response.statusText }));
                throw new Error(errorData.detail || `HTTP错误: ${response.status}`);
            }
            
            const result = await response.json();
            
            if (result.success) {
                alert(`备份集 ${setId} 删除成功`);
                // 重新加载备份集列表
                const monthSelect = document.getElementById('monthSelect');
                if (monthSelect && monthSelect.value) {
                    loadBackupSets(monthSelect.value);
                }
                // 清空文件树
                if (typeof treeRoot !== 'undefined') {
                    treeRoot.innerHTML = '<div class="text-center text-muted py-3">请选择一个备份集</div>';
                }
                // 重置当前备份集
                currentBackupSetId = null;
                if (currentBackupNameEl) {
                    currentBackupNameEl.textContent = '未选择';
                }
            } else {
                alert(`删除失败: ${result.message || '未知错误'}`);
            }
        } catch (error) {
            console.error('删除备份集失败:', error);
            alert('删除备份集失败: ' + error.message);
        }
    }

    // 从API加载备份集顶层目录（优化性能，按需加载）
    async function loadBackupSetFiles(backupSetId) {
        try {
            console.log('开始加载顶层目录，备份集ID:', backupSetId);
            treeRoot.innerHTML = '<div class="text-center text-muted py-3"><i class="bi bi-hourglass-split me-2"></i>正在加载目录结构...</div>';
            
            const url = `/api/recovery/backup-sets/${encodeURIComponent(backupSetId)}/top-level`;
            console.log('请求URL:', url);
            const response = await fetch(url);
            
            if (!response.ok) {
                throw new Error(`HTTP错误: ${response.status} ${response.statusText}`);
            }
            
            const data = await response.json();
            console.log('API返回数据:', data);
            const items = data.items || [];
            console.log('顶层目录项数量:', items.length);
            
            // 清空文件树和索引
            treeRoot.innerHTML = '';
            fileIndex.clear();
            autoId = 1;
            selectedFiles.clear();
            selectedFolders.clear();
            refreshStatsAndList();
            
            // 渲染顶层目录
            if (items.length === 0) {
                treeRoot.innerHTML = '<div class="text-center text-muted py-3">该备份集没有文件</div>';
                return;
            }
            
            console.log('开始渲染顶层节点，数量:', items.length);
            items.forEach(item => {
                renderTopLevelNode(item, backupSetId);
            });
            console.log('顶层节点渲染完成');
            
            // 自动展开 D: 目录并显示下一级
            setTimeout(() => {
                const dDriveNode = Array.from(treeRoot.querySelectorAll('.tree-node')).find(node => {
                    const nameSpan = node.querySelector('span:not(.tree-toggle):not(small)');
                    return nameSpan && nameSpan.textContent.trim() === 'D:';
                });
                if (dDriveNode) {
                    console.log('找到 D: 目录，自动展开');
                    toggleNode(dDriveNode);
                }
            }, 100);
        } catch (error) {
            console.error('加载目录结构失败:', error);
            treeRoot.innerHTML = '<div class="alert alert-danger">加载目录结构失败: ' + error.message + '</div>';
        }
    }
    
    // 渲染顶层节点
    function renderTopLevelNode(item, backupSetId) {
        const isDir = item.type === 'directory';
        const hasChildren = item.has_children !== false;
        
        const nodeEl = document.createElement('div');
        nodeEl.className = 'tree-node' + (hasChildren ? '' : ' leaf');
        nodeEl.dataset.id = 'n' + (autoId++);
        nodeEl.dataset.path = item.path;
        nodeEl.dataset.level = '0';
        nodeEl.dataset.backupSetId = backupSetId;
        
        const id = nodeEl.dataset.id;
        const sizeBytes = item.file ? (item.file.file_size || 0) : 0;
        
        // 创建节点内容容器
        const nodeContent = document.createElement('div');
        nodeContent.className = 'tree-node-content';
        nodeContent.style.display = 'flex';
        nodeContent.style.alignItems = 'center';
        nodeContent.style.flex = '1';
        nodeContent.style.minWidth = '0';
        
        // 展开/折叠按钮（仅目录且有子节点时显示）
        const toggleBtn = document.createElement('span');
        toggleBtn.className = 'tree-toggle';
        if (hasChildren) {
            toggleBtn.innerHTML = '<i class="bi bi-chevron-right"></i>';
            toggleBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                toggleNode(nodeEl);
            });
        } else {
            toggleBtn.innerHTML = '<span style="width:16px;"></span>';
        }
        
        // 复选框
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'form-check-input me-2';
        
        // 图标
        const icon = document.createElement('i');
        icon.className = `bi ${isDir ? 'bi-folder' : getFileIcon(item.file?.file_name || item.name)} me-2`;
        
        // 名称
        const nameSpan = document.createElement('span');
        nameSpan.textContent = item.name;
        
        // 大小（仅文件）
        const sizeSpan = document.createElement('small');
        sizeSpan.className = 'text-muted ms-2';
        if (!isDir && sizeBytes > 0) {
            sizeSpan.textContent = formatBytes(sizeBytes);
        }
        
        // 组装节点内容
        nodeContent.appendChild(toggleBtn);
        nodeContent.appendChild(checkbox);
        nodeContent.appendChild(icon);
        nodeContent.appendChild(nameSpan);
        if (!isDir && sizeBytes > 0) {
            nodeContent.appendChild(sizeSpan);
        }
        
        // 子节点容器（懒加载）
        const childrenContainer = document.createElement('div');
        childrenContainer.className = 'tree-children';
        
        // 组装节点
        nodeEl.appendChild(nodeContent);
        nodeEl.appendChild(childrenContainer);
        
        // 点击节点名称区域展开/折叠（仅目录）
        if (hasChildren) {
            nameSpan.style.cursor = 'pointer';
            nameSpan.addEventListener('click', function(e) {
                e.stopPropagation();
                toggleNode(nodeEl);
            });
        }
        
        fileIndex.set(id, {
            el: nodeEl,
            type: isDir ? 'dir' : 'file',
            sizeBytes: sizeBytes,
            children: [],
            childrenData: null, // 懒加载，初始为null
            name: item.name,
            file: item.file,
            path: item.path,
            expanded: false,
            rendered: true,
            backupSetId: backupSetId,
            loading: false // 是否正在加载
        });
        
        treeRoot.appendChild(nodeEl);
    }

    // 展开/折叠节点（按需加载）
    async function toggleNode(nodeEl) {
        const id = nodeEl.dataset.id;
        const meta = fileIndex.get(id);
        if (!meta || meta.type !== 'dir') return;
        
        if (meta.expanded) {
            // 折叠：隐藏子节点
            nodeEl.classList.remove('expanded');
            meta.expanded = false;
            const childrenContainer = nodeEl.querySelector('.tree-children');
            if (childrenContainer) {
                childrenContainer.innerHTML = '';
            }
        } else {
            // 展开：加载并渲染子节点
            nodeEl.classList.add('expanded');
            meta.expanded = true;
            const childrenContainer = nodeEl.querySelector('.tree-children');
            
            if (!childrenContainer) return;
            
            // 如果已经加载过，直接渲染
            if (meta.childrenData && meta.childrenData.length > 0) {
                const startId = autoId;
                renderChildren(childrenContainer, meta.childrenData, parseInt(nodeEl.dataset.level) + 1, meta.backupSetId);
                // 等待DOM更新完成后再设置children数组
                await new Promise(resolve => setTimeout(resolve, 50));
                // 从DOM中获取实际渲染的子节点ID
                const renderedNodes = Array.from(childrenContainer.querySelectorAll('.tree-node'));
                meta.children = renderedNodes.map(node => node.dataset.id);
                console.log(`节点 ${meta.name} 已渲染的子节点，children数组:`, meta.children);
                return;
            }
            
            // 如果正在加载，不重复加载
            if (meta.loading) return;
            
            // 从API加载子目录内容
            meta.loading = true;
            childrenContainer.innerHTML = '<div class="text-center text-muted py-2"><i class="bi bi-hourglass-split me-2"></i>加载中...</div>';
            
            try {
                const path = meta.path || '';
                const backupSetId = meta.backupSetId || currentBackupSetId;
                const response = await fetch(
                    `/api/recovery/backup-sets/${encodeURIComponent(backupSetId)}/directory?path=${encodeURIComponent(path)}`
                );
                const data = await response.json();
                const items = data.items || [];
                
                // 保存子节点数据
                meta.childrenData = items;
                
                // 渲染子节点
                const startId = autoId;
                renderChildren(childrenContainer, items, parseInt(nodeEl.dataset.level) + 1, backupSetId);
                
                // 等待DOM更新完成后再设置children数组
                await new Promise(resolve => setTimeout(resolve, 100));
                // 从DOM中获取实际渲染的子节点ID
                const renderedNodes = Array.from(childrenContainer.querySelectorAll('.tree-node'));
                meta.children = renderedNodes.map(node => node.dataset.id);
                console.log(`节点 ${meta.name} 加载并渲染了 ${items.length} 个子节点，children数组:`, meta.children);
            } catch (error) {
                console.error('加载子目录失败:', error);
                childrenContainer.innerHTML = '<div class="alert alert-danger py-2">加载失败: ' + error.message + '</div>';
            } finally {
                meta.loading = false;
            }
        }
    }
    
    // 渲染子节点
    function renderChildren(container, items, level, backupSetId) {
        container.innerHTML = '';
        items.forEach(item => {
            const childEl = renderChildNode(item, container, level, backupSetId);
        });
    }
    
    // 渲染子节点
    function renderChildNode(item, parentEl, level, backupSetId) {
        const isDir = item.type === 'directory';
        const hasChildren = item.has_children !== false;
        
        const nodeEl = document.createElement('div');
        nodeEl.className = 'tree-node' + (hasChildren ? '' : ' leaf');
        nodeEl.dataset.id = 'n' + (autoId++);
        nodeEl.dataset.path = item.path;
        nodeEl.dataset.level = level;
        nodeEl.dataset.backupSetId = backupSetId;
        
        const id = nodeEl.dataset.id;
        const sizeBytes = item.file ? (item.file.file_size || 0) : 0;
        
        // 创建节点内容容器
        const nodeContent = document.createElement('div');
        nodeContent.className = 'tree-node-content';
        nodeContent.style.display = 'flex';
        nodeContent.style.alignItems = 'center';
        nodeContent.style.flex = '1';
        nodeContent.style.minWidth = '0';
        
        // 展开/折叠按钮
        const toggleBtn = document.createElement('span');
        toggleBtn.className = 'tree-toggle';
        if (hasChildren) {
            toggleBtn.innerHTML = '<i class="bi bi-chevron-right"></i>';
            toggleBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                toggleNode(nodeEl);
            });
        } else {
            toggleBtn.innerHTML = '<span style="width:16px;"></span>';
        }
        
        // 复选框
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'form-check-input me-2';
        
        // 图标
        const icon = document.createElement('i');
        icon.className = `bi ${isDir ? 'bi-folder' : getFileIcon(item.file?.file_name || item.name)} me-2`;
        
        // 名称
        const nameSpan = document.createElement('span');
        nameSpan.textContent = item.name;
        
        // 大小（仅文件）
        const sizeSpan = document.createElement('small');
        sizeSpan.className = 'text-muted ms-2';
        if (!isDir && sizeBytes > 0) {
            sizeSpan.textContent = formatBytes(sizeBytes);
        }
        
        // 组装节点内容
        nodeContent.appendChild(toggleBtn);
        nodeContent.appendChild(checkbox);
        nodeContent.appendChild(icon);
        nodeContent.appendChild(nameSpan);
        if (!isDir && sizeBytes > 0) {
            nodeContent.appendChild(sizeSpan);
        }
        
        // 子节点容器
        const childrenContainer = document.createElement('div');
        childrenContainer.className = 'tree-children';
        
        // 组装节点
        nodeEl.appendChild(nodeContent);
        nodeEl.appendChild(childrenContainer);
        
        // 点击节点名称区域展开/折叠（仅目录）
        if (hasChildren) {
            nameSpan.style.cursor = 'pointer';
            nameSpan.addEventListener('click', function(e) {
                e.stopPropagation();
                toggleNode(nodeEl);
            });
        }
        
        fileIndex.set(id, {
            el: nodeEl,
            type: isDir ? 'dir' : 'file',
            sizeBytes: sizeBytes,
            children: [],
            childrenData: null,
            name: item.name,
            file: item.file,
            path: item.path,
            expanded: false,
            rendered: true,
            backupSetId: backupSetId,
            loading: false
        });
        
        if (parentEl) {
            parentEl.appendChild(nodeEl);
        }
        
        return nodeEl;
    }

    // 获取文件图标
    function getFileIcon(fileName) {
        const ext = fileName.split('.').pop()?.toLowerCase() || '';
        const iconMap = {
            'pdf': 'bi-file-pdf',
            'doc': 'bi-file-word', 'docx': 'bi-file-word',
            'xls': 'bi-file-earmark-spreadsheet', 'xlsx': 'bi-file-earmark-spreadsheet',
            'jpg': 'bi-file-image', 'jpeg': 'bi-file-image', 'png': 'bi-file-image', 'gif': 'bi-file-image',
            'txt': 'bi-file-text',
            'zip': 'bi-file-zip', '7z': 'bi-file-zip', 'rar': 'bi-file-zip'
        };
        return iconMap[ext] || 'bi-file-earmark-text';
    }

    // 获取备份类型样式类
    function getBackupTypeClass(type) {
        const typeMap = {
            'full': 'full',
            'monthly_full': 'full',
            'incremental': 'incremental',
            'differential': 'differential'
        };
        return typeMap[type] || 'full';
    }

    // 获取备份类型名称
    function getBackupTypeName(type) {
        const typeMap = {
            'full': '完整备份',
            'monthly_full': '完整备份',
            'incremental': '增量备份',
            'differential': '差异备份'
        };
        return typeMap[type] || '备份';
    }

    // 获取备份类型短名称
    function getBackupTypeShortName(type) {
        const typeMap = {
            'full': '完整',
            'monthly_full': '完整',
            'incremental': '增量',
            'differential': '差异'
        };
        return typeMap[type] || '备份';
    }

    // 获取备份类型徽章样式
    function getBackupTypeBadge(type) {
        const typeMap = {
            'full': 'bg-success',
            'monthly_full': 'bg-success',
            'incremental': 'bg-primary',
            'differential': 'bg-warning'
        };
        return typeMap[type] || 'bg-secondary';
    }

    function assignIdsAndBuildIndex(container){
        // 已由 buildFileTree 处理，此函数保留用于兼容
    }

    // 备份集选择联动
    function bindTimelineSelection(){
        // 已在 loadBackupSets 中处理
    }

    // 切换按钮
    if (changeBackupBtn && timeline){
        changeBackupBtn.addEventListener('click', function(){
            timeline.scrollIntoView({behavior:'smooth', block:'start'});
            const sel = timeline.querySelector('.backup-set-card.selected') || timeline.querySelector('.backup-set-card');
            if (sel){ sel.classList.add('selected'); sel.style.outline='2px solid #2196f3'; setTimeout(()=> sel.style.outline='', 1200); }
        });
    }

    // 月份下拉：加载对应月份的备份集
    if (monthSelect){
        monthSelect.addEventListener('change', async function(){
            await loadBackupSets(this.value);
        });
    }

    // 递归选择所有子节点的辅助函数
    async function selectAllChildren(parentId, on, maxDepth = 10, currentDepth = 0) {
        if (currentDepth >= maxDepth) {
            console.warn('达到最大递归深度，停止选择子节点');
            return;
        }
        
        const meta = fileIndex.get(parentId);
        if (!meta || meta.type !== 'dir') return;
        
        // 如果子节点未加载，先加载并展开
        if (meta.has_children !== false && !meta.expanded && !meta.childrenData) {
            console.log(`展开节点 ${meta.name} 以加载子节点`);
            await toggleNode(meta.el);
            // 等待子节点加载完成
            let retryCount = 0;
            while (!meta.childrenData && retryCount < 10) {
                await new Promise(resolve => setTimeout(resolve, 200));
                retryCount++;
            }
        }
        
        // 如果子节点数据已加载但未渲染，先渲染
        if (meta.childrenData && meta.childrenData.length > 0) {
            const childrenContainer = meta.el.querySelector('.tree-children');
            if (childrenContainer) {
                // 检查是否已经渲染了子节点
                const renderedCount = childrenContainer.querySelectorAll('.tree-node').length;
                if (renderedCount === 0) {
                    console.log(`渲染节点 ${meta.name} 的子节点，数量: ${meta.childrenData.length}`);
                    renderChildren(childrenContainer, meta.childrenData, parseInt(meta.el.dataset.level) + 1, meta.backupSetId);
                    const startId = autoId;
                    meta.children = meta.childrenData.map((_, idx) => 'n' + (startId + idx));
                    autoId += meta.childrenData.length;
                    // 等待DOM更新
                    await new Promise(resolve => setTimeout(resolve, 100));
                } else if (!meta.children || meta.children.length === 0) {
                    // 如果已渲染但children未设置，从DOM中获取
                    const childNodes = Array.from(childrenContainer.querySelectorAll('.tree-node'));
                    meta.children = childNodes.map(node => node.dataset.id);
                }
            }
        }
        
        // 递归处理所有子节点
        if (meta.children && meta.children.length > 0) {
            console.log(`处理节点 ${meta.name} 的 ${meta.children.length} 个子节点`);
            for (const chId of meta.children) {
                if (typeof chId === 'string' && chId.startsWith('n')) {
                    const childMeta = fileIndex.get(chId);
                    if (childMeta && childMeta.el) {
                        // 设置复选框状态 - 直接设置，不触发change事件避免循环
                        const childCb = childMeta.el.querySelector('input[type="checkbox"]');
                        if (childCb) {
                            // 标记正在处理，避免触发change事件
                            childCb.dataset.processing = 'true';
                            childCb.checked = !!on;
                            delete childCb.dataset.processing;
                        } else {
                            console.warn(`未找到子节点 ${childMeta.name} 的复选框`);
                        }
                        
                        // 更新选中状态和样式
                        if (on) {
                            childMeta.el.classList.add('selected');
                            if (childMeta.type === 'file') {
                                selectedFiles.add(chId);
                            } else {
                                selectedFolders.add(chId);
                            }
                        } else {
                            childMeta.el.classList.remove('selected');
                            if (childMeta.type === 'file') {
                                selectedFiles.delete(chId);
                            } else {
                                selectedFolders.delete(chId);
                            }
                        }
                        
                        // 如果是目录，递归处理其子节点
                        if (childMeta.type === 'dir') {
                            await selectAllChildren(chId, on, maxDepth, currentDepth + 1);
                        }
                    } else {
                        console.warn(`未找到子节点ID ${chId} 的元数据`);
                    }
                }
            }
        } else {
            console.log(`节点 ${meta.name} 没有子节点或children数组为空`);
        }
    }

    async function selectFile(id, on){
        const meta = fileIndex.get(id); 
        if (!meta) return;
        
        const cb = meta.el.querySelector('input[type="checkbox"]');
        if (cb) {
            // 标记正在处理，避免触发change事件导致循环
            cb.dataset.processing = 'true';
            cb.checked = !!on;
            delete cb.dataset.processing;
        }
        
        // 更新选中状态和样式
        if (on) {
            meta.el.classList.add('selected');
        } else {
            meta.el.classList.remove('selected');
        }
        
        if (meta.type === 'file'){
            if (on) {
                selectedFiles.add(id);
            } else {
                selectedFiles.delete(id);
            }
        } else {
            // 目录节点
            if (on) {
                selectedFolders.add(id);
            } else {
                selectedFolders.delete(id);
            }
            
            // 递归选择/取消选择所有子节点
            console.log(`${on ? '选择' : '取消选择'}目录 ${meta.name}，开始处理子节点`);
            await selectAllChildren(id, on);
        }
        
        refreshStatsAndList();
    }

    function refreshStatsAndList(){
        let files = Array.from(selectedFiles);
        let total = 0;
        files.forEach(id => { const m = fileIndex.get(id); if (m) total += m.sizeBytes; });
        selectedCountEl.textContent = String(files.length);
        selectedSizeEl.textContent = formatBytes(total);
        folderCountEl.textContent = String(selectedFolders.size);
        
        // 更新开始恢复按钮状态
        if (startRecoveryBtn) {
            startRecoveryBtn.disabled = files.length === 0 || !currentBackupSetId;
        }
        
        // 渲染列表
        listEl.innerHTML = files.map(id => {
            const m = fileIndex.get(id); if (!m) return '';
            return `<div class="list-group-item d-flex justify-content-between align-items-center">
                        <div class="text-truncate" style="max-width:75%"><i class="bi bi-file-earmark-text me-2"></i>${m.name}</div>
                        <div class="d-flex align-items-center gap-3">
                            <span class="text-muted small">${formatBytes(m.sizeBytes)}</span>
                            <button type="button" class="btn btn-sm btn-outline-danger" data-remove-id="${id}"><i class="bi bi-x"></i></button>
                        </div>
                    </div>`;
        }).join('');
    }

    // 事件委托：树复选框点击
    treeRoot.addEventListener('change', function(e){
        const target = e.target;
        if (target && target.matches('input[type="checkbox"]')){
            const node = target.closest('.tree-node');
            if (!node) return;
            const nodeId = node.dataset.id;
            if (!nodeId) return;
            
            // 防止递归调用导致的无限循环
            if (target.dataset.processing) return;
            target.dataset.processing = 'true';
            
            selectFile(nodeId, target.checked).finally(() => {
                delete target.dataset.processing;
            });
        }
    });

    // 事件：选中文件列表移除
    listEl.addEventListener('click', function(e){
        const btn = e.target.closest('button[data-remove-id]');
        if (!btn) return;
        const id = btn.getAttribute('data-remove-id');
        selectFile(id, false);
    });

    // 全选/清除
    if (selectAllBtn){
        selectAllBtn.addEventListener('click', function(){
            fileIndex.forEach((meta, id) => { if (meta.type==='file') selectFile(id, true); });
        });
    }
    if (clearSelectionBtn){
        clearSelectionBtn.addEventListener('click', function(){
            Array.from(selectedFiles).forEach(id => selectFile(id, false));
            Array.from(selectedFolders).forEach(id => selectFile(id, false));
        });
    }

    // 文件搜索
    if (fileSearch) {
        fileSearch.addEventListener('input', function() {
            const searchTerm = this.value.toLowerCase().trim();
            if (!searchTerm) {
                // 显示所有文件
                fileIndex.forEach((meta, id) => {
                    meta.el.style.display = '';
                });
                return;
            }
            
            // 过滤文件
            fileIndex.forEach((meta, id) => {
                const match = meta.name.toLowerCase().includes(searchTerm) || 
                             (meta.file && meta.file.file_path && meta.file.file_path.toLowerCase().includes(searchTerm));
                meta.el.style.display = match ? '' : 'none';
            });
        });
    }

    // 文件类型过滤
    if (fileTypeFilter) {
        fileTypeFilter.addEventListener('change', function() {
            const filterType = this.value;
            fileIndex.forEach((meta, id) => {
                if (filterType === '所有文件') {
                    meta.el.style.display = '';
                } else if (filterType === '仅显示文件') {
                    meta.el.style.display = meta.type === 'file' ? '' : 'none';
                } else if (filterType === '仅显示文件夹') {
                    meta.el.style.display = meta.type === 'dir' ? '' : 'none';
                }
            });
        });
    }

    // 开始恢复按钮
    if (startRecoveryBtn) {
        startRecoveryBtn.addEventListener('click', async function() {
            if (!currentBackupSetId || selectedFiles.size === 0) {
                alert('请先选择备份集和要恢复的文件');
                return;
            }

            const recoveryPath = document.getElementById('recoveryPath')?.value || '/tmp/recovery';
            const selectedFileList = Array.from(selectedFiles).map(id => {
                const meta = fileIndex.get(id);
                if (!meta || !meta.file) return null;
                return {
                    id: meta.file.id,
                    file_path: meta.file.file_path,
                    file_name: meta.file.file_name,
                    file_size: meta.file.file_size,
                    compressed_size: meta.file.compressed_size
                };
            }).filter(f => f !== null);

            if (selectedFileList.length === 0) {
                alert('没有有效的文件可以恢复');
                return;
            }

            try {
                this.disabled = true;
                this.textContent = '恢复中...';

                const response = await fetch('/api/recovery/tasks', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        backup_set_id: currentBackupSetId,
                        files: selectedFileList,
                        target_path: recoveryPath
                    })
                });

                const result = await response.json();
                
                if (result.success) {
                    alert('恢复任务已创建，正在后台执行');
                    // 可以在这里添加任务状态监控
                } else {
                    alert('创建恢复任务失败: ' + (result.message || '未知错误'));
                }
            } catch (error) {
                console.error('创建恢复任务失败:', error);
                alert('创建恢复任务失败: ' + error.message);
            } finally {
                this.disabled = false;
                this.textContent = '<i class="bi bi-play-circle me-2"></i>开始恢复';
            }
        });
    }

    // 初始化：加载备份组
    loadBackupGroups();
})();
</script>
{% endblock %}