# 格式化流程详解

## 概述

本文档详细说明磁带格式化和格式化后续操作的完整执行流程，包括异步执行机制、状态更新逻辑和错误处理。

**重要说明**：格式化和后续操作是**顺序执行**的，使用 `await` 关键字确保每个步骤完成后再执行下一步。

## 一、格式化执行流程

### 1.1 触发格式化

**位置**: `web/api/tape/crud.py` - `update_tape()` 函数

**触发条件**:
- 用户从扫描结果更新磁带时，`format_tape=True`
- 或者创建新磁带时，`format_tape=True`

**执行步骤**:

```
1. 用户点击"更新"按钮
   ↓
2. 前端发送 PUT /api/tape/update/{tape_id} 请求
   ↓
3. 后端检查 format_tape 参数
   ↓
4. 如果 format_tape=True，执行格式化流程
```

### 1.2 格式化前的准备工作

**代码位置**: `web/api/tape/crud.py:887-892`

```python
# 1. 保存变量供后台任务使用
background_label = label          # 卷标
background_serial = serial_param  # 序列号
background_tape_id = tape_id      # 磁带ID
background_system = system         # 系统实例

# 2. 将状态设置为 MAINTENANCE（格式化中）
UPDATE tape_cartridges SET status = 'MAINTENANCE' WHERE tape_id = {tape_id}
```

**状态变化**: `AVAILABLE` → `MAINTENANCE`

### 1.3 创建后台格式化任务

**代码位置**: `web/api/tape/crud.py:894-1043`

**执行方式**: 使用 `asyncio.create_task()` 创建异步后台任务

```python
async def format_tape_background():
    # 后台执行格式化，不阻塞API响应
    ...

# 立即返回API响应，不等待格式化完成
asyncio.create_task(format_tape_background())
```

**关键点**:
- API立即返回响应，不阻塞web请求
- 格式化在后台异步执行
- 前端可以继续操作，不受影响

## 二、格式化命令执行

### 2.1 格式化命令构建

**代码位置**: `utils/tape_tools.py:747-786`

**命令格式**:
```bash
LtfsCmdFormat.exe O /N:TP20241101 /S:TP1101
```

**参数说明**:
- `O`: 盘符（不带冒号）
- `/N:{volume_label}`: 卷标名称
- `/S:{serial}`: 序列号（6位大写字母数字）
- `/E`: 格式化后弹出（可选）

### 2.2 命令执行机制

**代码位置**: `utils/tape_tools.py:51-203`

**执行流程**:

```
1. 创建子进程
   ↓
   asyncio.create_subprocess_exec(
       *cmd,
       stdout=asyncio.subprocess.PIPE,
       stderr=asyncio.subprocess.PIPE,
       cwd=working_dir
   )
   ↓
2. 等待进程结束（最多3600秒超时）
   ↓
   returncode = await asyncio.wait_for(proc.wait(), timeout=3600)
   ↓
   [关键：proc.wait() 会立即返回，当进程结束时（无论成功/失败）]
   ↓
3. 进程结束后，读取输出
   ↓
   - 分块读取stdout（每次4KB）
   - 分块读取stderr（每次4KB）
   - 超时30秒
   ↓
4. 判断成功/失败
   ↓
   success = returncode == 0
```

**关键机制**:
- **异步执行**: 使用 `asyncio.create_subprocess_exec` 异步创建进程
- **超时控制**: 格式化命令最多执行3600秒（1小时）
- **立即返回**: `proc.wait()` 会在进程结束时立即返回，**不会等待满3600秒**
- **输出读取**: 进程结束后分块读取，避免阻塞
- **返回码检测**: `returncode == 0` 表示成功

**重要说明**：
- ✅ **格式化成功**：进程正常结束（returncode=0），立即跳出，不会等待3600秒
- ✅ **格式化失败**：进程异常结束（returncode!=0），立即跳出，不会等待3600秒
- ✅ **格式化异常**：进程抛出异常，立即跳出，不会等待3600秒
- ✅ **格式化完成**：进程完成（无论成功失败），立即跳出，不会等待3600秒
- ⚠️ **超时情况**：只有进程运行超过3600秒时，才会触发 `TimeoutError`，然后强制终止进程

### 2.3 输出读取优化

**问题**: 一次性读取大量输出可能导致阻塞

**解决方案**: 分块读取（每次4KB）

```python
async def read_stdout():
    data = b""
    while True:
        chunk = await proc.stdout.read(4096)  # 每次4KB
        if not chunk:
            break
        data += chunk
    return data
```

**优势**:
- 避免一次性读取大量数据导致内存问题
- 进程结束后读取，不会阻塞
- 超时保护（30秒）

## 三、格式化后续操作（顺序执行）

### 3.1 执行顺序

**代码位置**: `web/api/tape/crud.py:925-1001`

**重要**: 所有后续操作都是**顺序执行**的，使用 `await` 关键字确保每个步骤完成后再执行下一步。

**执行流程**:

```
步骤1: 等待格式化命令完成
   ↓
   format_result = await tape_tools_manager.format_tape_ltfs(...)
   ↓
   [等待格式化命令执行完成，可能需要几分钟到几十分钟]
   ↓
步骤2: 检查格式化结果
   ↓
   if format_result.get("success"):
   ↓
步骤3: 等待2秒，确保格式化完全完成
   ↓
   await asyncio.sleep(2)
   ↓
   [等待2秒]
   ↓
步骤4: 读取磁盘上的实际卷标和序列号
   ↓
   label_result = await tape_tools_manager.read_tape_label_windows()
   ↓
   [等待读取完成，通常几秒钟]
   ↓
步骤5: 解析读取结果
   ↓
   actual_label = label_result.get("volume_name", "").strip()
   actual_serial = label_result.get("serial_number", "").strip()
   ↓
步骤6: 比较实际值与预期值
   ↓
   if actual_label != background_label:
       → 更新数据库卷标
   if actual_serial != background_serial:
       → 更新数据库序列号
   ↓
步骤7: 更新数据库状态为 AVAILABLE
   ↓
   UPDATE tape_cartridges SET status = 'AVAILABLE' WHERE tape_id = {tape_id}
   ↓
步骤8: 记录日志
   ↓
   logger.info("格式化完成，状态设置为 AVAILABLE")
```

### 3.2 顺序执行的原因

**为什么必须顺序执行？**

1. **格式化命令必须完成**：只有格式化完成后，磁盘上才有卷标和序列号
2. **读取卷标依赖格式化**：必须先格式化完成，才能读取卷标
3. **数据库更新依赖读取结果**：必须先读取到实际值，才能更新数据库

**代码示例**:
```python
# 步骤1: 等待格式化完成（阻塞，直到格式化命令结束）
format_result = await tape_tools_manager.format_tape_ltfs(...)

# 步骤2: 检查结果（同步）
if format_result.get("success"):
    # 步骤3: 等待2秒（阻塞2秒）
    await asyncio.sleep(2)
    
    # 步骤4: 读取卷标（阻塞，直到读取完成）
    label_result = await tape_tools_manager.read_tape_label_windows()
    
    # 步骤5: 更新数据库（同步）
    # ...
```

### 3.3 格式化成功后的操作

**代码位置**: `web/api/tape/crud.py:925-1001`

**执行流程**:

```
格式化命令返回 success=True
   ↓
1. 等待2秒，确保格式化完全完成
   await asyncio.sleep(2)
   ↓
2. 读取磁盘上的实际卷标和序列号
   label_result = await tape_tools_manager.read_tape_label_windows()
   ↓
3. 比较实际值与预期值
   - 如果实际卷标 != 预期卷标 → 更新数据库卷标
   - 如果实际序列号 != 预期序列号 → 更新数据库序列号
   ↓
4. 更新数据库状态为 AVAILABLE
   UPDATE tape_cartridges SET status = 'AVAILABLE' WHERE tape_id = {tape_id}
   ↓
5. 记录日志
   logger.info("格式化完成，状态设置为 AVAILABLE")
```

**状态变化**: `MAINTENANCE` → `AVAILABLE`

### 3.4 读取卷标机制

**代码位置**: `utils/tape_tools.py:857-874`

**使用工具**: Windows `fsutil` 命令

**命令**:
```bash
fsutil fsinfo volumeinfo O:
```

**解析输出**:
- 提取 `卷名` (Volume Name) → 卷标
- 提取 `卷序列号` (Volume Serial Number) → 序列号

### 3.5 数据库更新逻辑

**更新条件**:
1. 格式化成功（`format_result.get("success") == True`）
2. 读取到实际卷标或序列号
3. 实际值与数据库中的值不同

**更新SQL**:
```sql
UPDATE tape_cartridges
SET label = %s, serial_number = %s, updated_at = NOW()
WHERE tape_id = %s
```

**状态更新**:
```sql
UPDATE tape_cartridges
SET status = 'AVAILABLE'
WHERE tape_id = %s
```

## 四、错误处理

### 4.1 格式化失败处理

**代码位置**: `web/api/tape/crud.py:1002-1026`

**触发条件**: `format_result.get("success") == False`

**处理流程**:

```
格式化命令返回 success=False
   ↓
1. 提取错误信息
   error_detail = stderr or stdout or "格式化失败"
   returncode = format_result.get("returncode", -1)
   ↓
2. 更新数据库状态为 ERROR
   UPDATE tape_cartridges SET status = 'ERROR' WHERE tape_id = {tape_id}
   ↓
3. 发送钉钉通知
   send_tape_format_notification(status="failed", ...)
   ↓
4. 记录错误日志
   logger.error("格式化失败 - 返回码: {returncode}, 错误详情: {error_detail}")
```

**状态变化**: `MAINTENANCE` → `ERROR`

### 4.2 格式化异常处理

**代码位置**: `web/api/tape/crud.py:1020-1039`

**触发条件**: 格式化过程中抛出异常

**处理流程**:

```
格式化过程中发生异常
   ↓
1. 捕获异常
   except Exception as e:
   ↓
2. 记录异常日志
   logger.error("后台格式化磁盘异常: {str(e)}", exc_info=True)
   ↓
3. 重新连接数据库
   db_conn = psycopg2.connect(...)
   ↓
4. 更新状态为 ERROR
   UPDATE tape_cartridges SET status = 'ERROR' WHERE tape_id = {tape_id}
   ↓
5. 记录错误日志
   logger.error("格式化异常，状态设置为 ERROR")
```

**状态变化**: `MAINTENANCE` → `ERROR`

### 4.3 读取卷标失败处理

**代码位置**: `web/api/tape/crud.py:983-1001`

**处理策略**:
- 即使读取卷标失败，格式化成功时仍将状态改为 `AVAILABLE`
- 因为格式化本身已经成功，读取失败可能是临时问题

## 五、状态流转图

```
初始状态: AVAILABLE
   ↓
[格式化开始]
   ↓
状态: MAINTENANCE (格式化中)
   ↓
[执行格式化命令] ← 顺序执行，等待完成
   ↓
   ├─→ 成功 (returncode == 0)
   │    ↓
   │   [等待2秒] ← 顺序执行
   │    ↓
   │   [读取卷标] ← 顺序执行，等待完成
   │    ↓
   │   [更新数据库] ← 顺序执行
   │    ↓
   │   状态: AVAILABLE (可用) ✅
   │
   ├─→ 失败 (returncode != 0)
   │    ↓
   │   [记录错误] ← 顺序执行
   │    ↓
   │   [发送通知] ← 顺序执行
   │    ↓
   │   状态: ERROR (故障) ❌
   │
   └─→ 异常 (Exception)
        ↓
       [捕获异常] ← 顺序执行
        ↓
       [更新状态] ← 顺序执行
        ↓
       状态: ERROR (故障) ❌
```

## 六、关键时间点

### 6.1 时间线

```
T0: 用户点击"更新"按钮
   ↓
T1: API接收请求，更新数据库状态为 MAINTENANCE
   ↓
T2: API立即返回响应（不等待格式化）
   ↓
T3: 后台任务开始执行格式化命令
   ↓
T4: LtfsCmdFormat.exe 开始执行（可能需要几分钟到几十分钟）
   ↓
T5: 格式化命令完成，返回结果 ← 顺序等待
   ↓
T6: 等待2秒，确保格式化完全完成 ← 顺序等待
   ↓
T7: 读取磁盘上的实际卷标和序列号 ← 顺序等待
   ↓
T8: 更新数据库（卷标、序列号、状态） ← 顺序执行
   ↓
T9: 状态更新为 AVAILABLE，流程完成
```

### 6.2 超时设置

- **格式化命令超时**: 3600秒（1小时）- **这是最大等待时间，不是实际等待时间**
- **读取输出超时**: 30秒
- **等待格式化完成**: 2秒

**超时机制说明**：
- `proc.wait()` 会在进程结束时立即返回，无论成功还是失败
- 只有进程运行超过3600秒时，才会触发超时并强制终止进程
- 正常情况下（成功/失败/异常），都会立即跳出，不会等待满3600秒

## 七、数据库更新时机

### 7.1 格式化前更新

- **状态**: `AVAILABLE` → `MAINTENANCE`
- **时机**: 格式化命令执行前
- **目的**: 防止格式化期间被其他操作使用

### 7.2 格式化后更新

- **卷标/序列号**: 根据磁盘实际值更新
- **状态**: `MAINTENANCE` → `AVAILABLE` 或 `ERROR`
- **时机**: 格式化命令完成后（顺序执行）
- **目的**: 确保数据库与实际磁盘状态一致

## 八、日志记录

### 8.1 关键日志点

1. **格式化开始**: `"格式化开始前，将磁带 {tape_id} 状态设置为 MAINTENANCE"`
2. **命令执行**: `"后台格式化磁盘: 卷标={label}, SN={serial}, 盘符={drive_letter}"`
3. **命令完成**: `"格式化命令执行完成 - 成功: {success}, 返回码: {returncode}"`
4. **读取卷标**: `"从磁盘读取到实际值: 卷标={label}, SN={serial}"`
5. **状态更新**: `"格式化完成，将磁带 {tape_id} 状态设置为 AVAILABLE"`
6. **失败处理**: `"格式化失败，将磁带 {tape_id} 状态设置为 ERROR"`

### 8.2 日志级别

- **INFO**: 正常流程日志
- **WARNING**: 警告信息（如读取卷标失败）
- **ERROR**: 错误信息（格式化失败、异常）

## 九、常见问题

### 9.1 Web阻塞问题

**原因**: 如果格式化命令同步执行，会阻塞web请求

**解决方案**: 使用 `asyncio.create_task()` 在后台异步执行

**注意**: 虽然格式化在后台执行，但格式化命令本身和后续操作是顺序执行的

### 9.2 状态不更新问题

**可能原因**:
1. 格式化命令未正确结束
2. 返回码检测失败
3. 数据库更新异常

**检查方法**: 查看日志中的返回码和状态更新记录

### 9.3 格式化完成但状态未变化

**可能原因**:
1. 读取卷标失败，但状态更新逻辑有bug
2. 数据库更新异常

**解决方案**: 已修复，确保在所有情况下都能更新状态

## 十、总结

### 10.1 执行方式

- **API响应**: 异步（立即返回）
- **格式化命令**: 异步执行（后台任务）
- **格式化后续操作**: **顺序执行**（使用 `await`）

### 10.2 顺序执行的操作

1. ✅ 等待格式化命令完成 (`await format_tape_ltfs()`)
2. ✅ 等待2秒 (`await asyncio.sleep(2)`)
3. ✅ 等待读取卷标完成 (`await read_tape_label_windows()`)
4. ✅ 更新数据库（同步操作）

### 10.3 关键点

- 使用 `asyncio.create_task()` 实现异步执行（不阻塞API）
- 使用 `await` 确保顺序执行（格式化→等待→读取→更新）
- 使用返回码判断成功/失败
- 在所有情况下都更新数据库状态

**重要**: 虽然格式化在后台异步执行，但格式化命令本身和后续操作（读取卷标、更新数据库）是**顺序执行**的，确保每个步骤完成后再执行下一步。

