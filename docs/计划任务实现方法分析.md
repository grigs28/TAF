# 计划任务实现方法分析

## 概述

本文档详细分析了企业级磁带备份系统中计划任务（Scheduled Task）的实现方法，包括数据模型、调度器实现、API接口以及多种调度方式的支持。

## 目录

1. [架构设计](#架构设计)
2. [数据模型](#数据模型)
3. [调度器实现](#调度器实现)
4. [调度方式](#调度方式)
5. [API接口](#api接口)
6. [功能特性](#功能特性)
7. [使用示例](#使用示例)

## 架构设计

### 整体架构

计划任务系统采用三层架构：

```
┌─────────────────┐
│   API Layer     │  FastAPI RESTful API
├─────────────────┤
│  Scheduler      │  TaskScheduler 调度器
├─────────────────┤
│  Database       │  ScheduledTask 数据模型
└─────────────────┘
```

### 核心组件

1. **数据模型层** (`models/scheduled_task.py`)
   - `ScheduledTask`: 计划任务主表
   - `ScheduledTaskLog`: 任务执行日志表
   - 枚举类型：`ScheduleType`, `ScheduledTaskStatus`, `TaskActionType`

2. **调度器层** (`utils/scheduler.py`)
   - `BackupScheduler`: 原有调度器（向后兼容）
   - `TaskScheduler`: 增强的调度器（支持数据库持久化）

3. **API层** (`web/api/scheduler.py`)
   - RESTful API接口，提供完整的CRUD操作

## 数据模型

### ScheduledTask（计划任务表）

#### 核心字段

- **基本信息**
  - `task_name`: 任务名称（唯一）
  - `description`: 任务描述
  - `status`: 任务状态（ACTIVE/INACTIVE/RUNNING/PAUSED/ERROR）
  - `enabled`: 是否启用

- **调度配置**
  - `schedule_type`: 调度类型（ONCE/INTERVAL/DAILY/WEEKLY/MONTHLY/YEARLY/CRON）
  - `schedule_config`: 调度配置（JSON格式，根据类型不同而不同）

- **任务动作配置**
  - `action_type`: 任务动作类型（BACKUP/RECOVERY/CLEANUP/HEALTH_CHECK/RETENTION_CHECK/CUSTOM）
  - `action_config`: 任务动作配置（JSON格式）

- **时间信息**
  - `next_run_time`: 下次执行时间
  - `last_run_time`: 上次执行时间
  - `last_success_time`: 上次成功执行时间
  - `last_failure_time`: 上次失败执行时间

- **执行统计**
  - `total_runs`: 总执行次数
  - `success_runs`: 成功次数
  - `failure_runs`: 失败次数
  - `average_duration`: 平均执行时长（秒）

### ScheduledTaskLog（任务执行日志表）

记录每次任务执行的详细信息：
- `execution_id`: 执行ID（UUID）
- `started_at`: 开始时间
- `completed_at`: 完成时间
- `duration`: 执行时长（秒）
- `status`: 执行状态（success/failed/running/cancelled）
- `error_message`: 错误信息
- `result`: 执行结果（JSON格式）

## 调度器实现

### TaskScheduler类

#### 核心方法

1. **初始化**
   ```python
   async def initialize(self, system_instance)
   ```
   - 从数据库加载已启用的计划任务
   - 计算每个任务的下次执行时间
   - 加载任务到内存

2. **任务管理**
   - `add_task()`: 添加计划任务
   - `delete_task()`: 删除计划任务
   - `update_task()`: 更新计划任务
   - `get_task()`: 获取单个任务
   - `get_tasks()`: 获取任务列表

3. **任务控制**
   - `run_task()`: 立即运行任务
   - `stop_task()`: 停止正在运行的任务
   - `enable_task()`: 启用任务
   - `disable_task()`: 禁用任务

4. **调度循环**
   ```python
   async def _scheduler_loop(self)
   ```
   - 每分钟检查一次所有任务
   - 如果当前时间 >= 下次执行时间，触发任务执行
   - 任务在后台异步执行，不阻塞调度器

#### 执行流程

```
调度器启动
    ↓
从数据库加载任务
    ↓
计算下次执行时间
    ↓
进入调度循环（每分钟检查）
    ↓
时间到达 → 创建执行函数 → 后台异步执行
    ↓
记录执行日志
    ↓
更新任务统计
    ↓
计算下次执行时间
```

## 调度方式

系统支持7种调度方式：

### 1. ONCE（一次性任务）

**用途**: 在指定日期时间执行一次

**配置示例**:
```json
{
  "datetime": "2024-12-25 14:30:00"
}
```

**实现逻辑**:
- 解析指定的日期时间
- 如果执行时间已过，任务不再执行
- 适用于临时任务或特定时间点的操作

### 2. INTERVAL（间隔任务）

**用途**: 每隔固定时间执行一次

**配置示例**:
```json
{
  "interval": 30,
  "unit": "minutes"  // 可选: minutes/hours/days
}
```

**实现逻辑**:
- 从未执行过：从当前时间 + 间隔
- 已执行过：从上次执行时间 + 间隔
- 如果下次执行时间已过，从当前时间重新计算
- 适用于定期检查、数据同步等场景

### 3. DAILY（每日任务）

**用途**: 每天固定时间执行

**配置示例**:
```json
{
  "time": "02:00:00"
}
```

**实现逻辑**:
- 设置每天的执行时间（时:分:秒）
- 如果今天的执行时间已过，执行明天的
- 适用于每天凌晨的备份任务

### 4. WEEKLY（每周任务）

**用途**: 每周固定星期几的固定时间执行

**配置示例**:
```json
{
  "day_of_week": 0,  // 0=Monday, 6=Sunday
  "time": "02:00:00"
}
```

**实现逻辑**:
- 计算距离目标星期几的天数
- 如果本周的执行时间已过，执行下周的
- 适用于每周的数据清理任务

### 5. MONTHLY（每月任务）

**用途**: 每月固定日期的固定时间执行

**配置示例**:
```json
{
  "day_of_month": 1,
  "time": "02:00:00"
}
```

**实现逻辑**:
- 设置每月的日期（1-31）
- 如果本月的执行时间已过，执行下个月的
- 处理月份天数不同的情况（如2月只有28/29天）
- 适用于月度备份任务

### 6. YEARLY（每年任务）

**用途**: 每年固定月日的固定时间执行

**配置示例**:
```json
{
  "month": 1,
  "day": 1,
  "time": "02:00:00"
}
```

**实现逻辑**:
- 设置年度的月、日、时
- 如果今年的执行时间已过，执行明年的
- 适用于年度归档任务

### 7. CRON（Cron表达式）

**用途**: 使用标准的Cron表达式

**配置示例**:
```json
{
  "cron": "0 2 * * *"  // 每天02:00
}
```

**实现逻辑**:
- 使用`croniter`库解析Cron表达式
- 计算下次执行时间
- 支持复杂的调度规则
- 适用于需要精确控制的场景

## API接口

### 任务管理接口

#### 1. 获取任务列表
```http
GET /api/scheduler/tasks?enabled_only=false
```

响应：
```json
[
  {
    "id": 1,
    "task_name": "每日备份",
    "schedule_type": "daily",
    "schedule_config": {"time": "02:00:00"},
    "action_type": "backup",
    "status": "active",
    "next_run_time": "2024-11-02T02:00:00",
    ...
  }
]
```

#### 2. 获取单个任务
```http
GET /api/scheduler/tasks/{task_id}
```

#### 3. 创建任务
```http
POST /api/scheduler/tasks
Content-Type: application/json

{
  "task_name": "每周清理",
  "schedule_type": "weekly",
  "schedule_config": {
    "day_of_week": 0,
    "time": "03:00:00"
  },
  "action_type": "cleanup",
  "action_config": {
    "retention_days": 30
  },
  "enabled": true
}
```

#### 4. 更新任务
```http
PUT /api/scheduler/tasks/{task_id}
Content-Type: application/json

{
  "schedule_config": {
    "time": "04:00:00"
  },
  "enabled": false
}
```

#### 5. 删除任务
```http
DELETE /api/scheduler/tasks/{task_id}
```

### 任务控制接口

#### 1. 立即运行任务
```http
POST /api/scheduler/tasks/{task_id}/run
```

#### 2. 停止运行中的任务
```http
POST /api/scheduler/tasks/{task_id}/stop
```

#### 3. 启用任务
```http
POST /api/scheduler/tasks/{task_id}/enable
```

#### 4. 禁用任务
```http
POST /api/scheduler/tasks/{task_id}/disable
```

### 日志查询接口

#### 获取任务执行日志
```http
GET /api/scheduler/tasks/{task_id}/logs?limit=100&offset=0
```

响应：
```json
{
  "logs": [
    {
      "execution_id": "uuid",
      "started_at": "2024-11-01T02:00:00",
      "completed_at": "2024-11-01T02:30:00",
      "duration": 1800,
      "status": "success",
      "result": {...}
    }
  ],
  "total": 50,
  "limit": 100,
  "offset": 0
}
```

### 状态查询接口

#### 获取调度器状态
```http
GET /api/scheduler/status
```

响应：
```json
{
  "running": true,
  "total_tasks": 10,
  "enabled_tasks": 8,
  "running_executions": 1
}
```

## 功能特性

### 1. 完整的CRUD操作

- ✅ **添加**: 创建新的计划任务，支持所有调度类型
- ✅ **删除**: 删除计划任务，自动停止正在运行的任务
- ✅ **编辑**: 更新任务配置，自动重新计算执行时间
- ✅ **查询**: 支持列表查询和单个查询

### 2. 任务控制

- ✅ **运行**: 立即执行任务（不等待调度时间）
- ✅ **停止**: 停止正在运行的任务
- ✅ **启用/禁用**: 启用或禁用任务（禁用后不会执行）

### 3. 多种调度方式

- ✅ **某月某日某时**（ONCE）: 一次性执行
- ✅ **间隔**（INTERVAL）: 每N分钟/小时/天执行
- ✅ **每日**（DAILY）: 每天固定时间执行
- ✅ **每周**（WEEKLY）: 每周固定星期几执行
- ✅ **每月**（MONTHLY）: 每月固定日期执行
- ✅ **每年**（YEARLY）: 每年固定月日执行
- ✅ **Cron表达式**（CRON）: 使用标准Cron表达式

### 4. 执行日志

- ✅ 记录每次任务执行的详细信息
- ✅ 包括执行时间、持续时间、状态、结果
- ✅ 支持错误信息记录
- ✅ 提供日志查询接口

### 5. 统计信息

- ✅ 总执行次数
- ✅ 成功/失败次数
- ✅ 平均执行时长
- ✅ 最后执行时间
- ✅ 最后成功/失败时间

### 6. 数据库持久化

- ✅ 所有任务配置存储在数据库中
- ✅ 系统重启后自动加载任务
- ✅ 执行历史永久保存

### 7. 异步执行

- ✅ 任务在后台异步执行
- ✅ 不阻塞调度器主循环
- ✅ 支持并发执行多个任务

## 使用示例

### 示例1：创建每日备份任务

```python
# 创建每日02:00执行的备份任务
task = ScheduledTask(
    task_name="每日完整备份",
    description="每天凌晨执行完整备份",
    schedule_type=ScheduleType.DAILY,
    schedule_config={
        "time": "02:00:00"
    },
    action_type=TaskActionType.BACKUP,
    action_config={
        "source_paths": ["/data"],
        "task_type": "full",
        "compression_enabled": True
    },
    enabled=True
)

await scheduler.add_task(task)
```

### 示例2：创建间隔检查任务

```python
# 每30分钟执行一次健康检查
task = ScheduledTask(
    task_name="系统健康检查",
    schedule_type=ScheduleType.INTERVAL,
    schedule_config={
        "interval": 30,
        "unit": "minutes"
    },
    action_type=TaskActionType.HEALTH_CHECK,
    action_config={},
    enabled=True
)

await scheduler.add_task(task)
```

### 示例3：创建一次性任务

```python
# 在指定时间执行一次性清理任务
task = ScheduledTask(
    task_name="临时清理任务",
    schedule_type=ScheduleType.ONCE,
    schedule_config={
        "datetime": "2024-12-25 14:30:00"
    },
    action_type=TaskActionType.CLEANUP,
    action_config={
        "retention_days": 90
    },
    enabled=True
)

await scheduler.add_task(task)
```

### 示例4：使用Cron表达式

```python
# 使用Cron表达式：每天02:00和14:00执行
task = ScheduledTask(
    task_name="每日两次备份",
    schedule_type=ScheduleType.CRON,
    schedule_config={
        "cron": "0 2,14 * * *"
    },
    action_type=TaskActionType.BACKUP,
    action_config={
        "source_paths": ["/data"],
        "task_type": "incremental"
    },
    enabled=True
)

await scheduler.add_task(task)
```

### 示例5：立即运行任务

```python
# 通过API立即运行任务
response = await client.post(f"/api/scheduler/tasks/{task_id}/run")
```

### 示例6：查看任务执行日志

```python
# 获取任务执行历史
logs = await client.get(f"/api/scheduler/tasks/{task_id}/logs?limit=10")
```

## 技术实现细节

### 1. 时间计算算法

不同调度类型的时间计算逻辑：

- **ONCE**: 直接使用指定时间，如果已过则不执行
- **INTERVAL**: 基于上次执行时间 + 间隔，如果已过则从当前时间重新计算
- **DAILY/WEEKLY/MONTHLY/YEARLY**: 基于当前时间计算下一个符合条件的时间点
- **CRON**: 使用`croniter`库计算

### 2. 任务执行机制

- 任务执行函数通过闭包创建，捕获任务对象
- 每次执行生成唯一的`execution_id`（UUID）
- 执行过程完全异步，不阻塞调度器
- 执行结果和错误信息记录到数据库

### 3. 状态管理

- **ACTIVE**: 任务已启用，等待执行
- **INACTIVE**: 任务已禁用，不会执行
- **RUNNING**: 任务正在执行中
- **PAUSED**: 任务被暂停（执行被中断）
- **ERROR**: 任务执行失败

### 4. 错误处理

- 任务执行失败时，记录错误信息到数据库
- 更新任务统计（failure_runs增加）
- 保持任务状态为ERROR，等待手动处理或下次执行

## 扩展性

### 1. 添加新的调度类型

在`ScheduleType`枚举中添加新类型，并在`_calculate_next_run_time`方法中实现计算逻辑。

### 2. 添加新的任务动作类型

在`TaskActionType`枚举中添加新类型，并在`_execute_task_action`方法中实现执行逻辑。

### 3. 自定义任务执行逻辑

通过`action_type=CUSTOM`和`action_config`实现自定义任务逻辑。

## 性能优化

1. **内存缓存**: 已启用的任务加载到内存，避免频繁查询数据库
2. **异步执行**: 任务执行不阻塞调度器主循环
3. **批量更新**: 任务统计信息批量更新到数据库
4. **索引优化**: 数据库字段建立索引，提高查询性能

## 注意事项

1. **时区处理**: 所有时间使用系统本地时区，存储时使用`timezone=True`
2. **并发控制**: 同一任务不会并发执行，如果任务正在运行，会跳过本次调度
3. **资源清理**: 任务执行完成后，自动清理执行记录，避免内存泄漏
4. **错误恢复**: 任务执行失败后，状态会更新为ERROR，需要手动处理

## 总结

计划任务系统提供了完整的任务管理功能，支持多种调度方式，具有良好的扩展性和可维护性。通过数据库持久化，确保了任务的可靠性和可追溯性。

## 相关文件

- `models/scheduled_task.py`: 数据模型定义
- `utils/scheduler.py`: 调度器实现
- `web/api/scheduler.py`: API接口定义
- `docs/计划任务实现方法分析.md`: 本文档

---

*文档生成时间: 2024-11-02*
*版本: 1.0*

